[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "24BSE2113D-Computational Methods for Electronics & Robotics Lab",
    "section": "",
    "text": "1 Welcome to the Computational Methods Lab\nThis interactive lab manual is designed for third-semester B.Tech students in Electronics and Robotics. The goal of this course is to introduce powerful computational techniques for solving common engineering problems using the Python programming language.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome to the Computational Methods Lab</span>"
    ]
  },
  {
    "objectID": "index.html#why-python",
    "href": "index.html#why-python",
    "title": "24BSE2113D-Computational Methods for Electronics & Robotics Lab",
    "section": "1.1 Why Python?",
    "text": "1.1 Why Python?\nWhile MATLAB is a traditional tool in engineering, Python has become the industry standard in modern robotics, machine learning, and data science. By learning Python, you are acquiring a versatile skill that is highly sought after in today’s tech landscape. It’s free, open-source, and has a vast ecosystem of libraries that we will leverage throughout this course.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome to the Computational Methods Lab</span>"
    ]
  },
  {
    "objectID": "index.html#software-setup",
    "href": "index.html#software-setup",
    "title": "24BSE2113D-Computational Methods for Electronics & Robotics Lab",
    "section": "1.2 Software Setup",
    "text": "1.2 Software Setup\nBefore you begin, please ensure you have the following installed on your system. We highly recommend installing the Anaconda Distribution, which packages Python and all the necessary libraries together.\n\nPython 3.8+\nNumPy: For numerical operations.\nMatplotlib: For plotting and visualization.\nSymPy: For symbolic mathematics (algebra and calculus).\nSciPy: For scientific computing, including optimization.\n\nYou can run the code in this book interactively by using a Jupyter Notebook or an IDE like Spyder or VS Code with Python extensions.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome to the Computational Methods Lab</span>"
    ]
  },
  {
    "objectID": "01-intro-python.html",
    "href": "01-intro-python.html",
    "title": "2  Lab Session 1: Python’s Scientific Stack",
    "section": "",
    "text": "2.1 Excercise 1: The Core Trio - NumPy, Matplotlib, and SymPy\nThis session introduces the fundamental libraries that make Python a powerhouse for engineering.\nObjective: To get comfortable creating arrays, plotting data, and performing symbolic calculations.",
    "crumbs": [
      "Fundamentals",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Lab Session 1: Python's Scientific Stack</span>"
    ]
  },
  {
    "objectID": "01-intro-python.html#excercise-1-the-core-trio---numpy-matplotlib-and-sympy",
    "href": "01-intro-python.html#excercise-1-the-core-trio---numpy-matplotlib-and-sympy",
    "title": "2  Lab Session 1: Python’s Scientific Stack",
    "section": "",
    "text": "2.1.1 Pyton basics- Recap\n\n2.1.1.1 Hello World\nThe classic first program for any language.\n\n\nCode\nprint(\"Hello, B.Tech Students!\")\n\n\nHello, B.Tech Students!\n\n\n\n\n2.1.1.2 Variables and Data Types\nIntroduction to different data types like integers, floats, and strings.\n\n\nCode\nx = 10  # Integer\ny = 3.5  # Float\nname = \"Python\"  # String\nis_student = True  # Boolean\n\nprint(x, y, name, is_student)\n\n\n10 3.5 Python True\n\n\n\n\n2.1.1.3 Conditional Statements\nUsing if, elif, and else statements.\n\n\nCode\nx = 10  # Integer\ny = 3.5  # Float\nname = \"Python\"  # String\nis_student = True  # Boolean\n\nprint(x, y, name, is_student)\n\n\n10 3.5 Python True\n\n\n\n\n2.1.1.4 Loops/ Iteratives\nUsing for and while loops.\n\n\nCode\n# For loop\nfor i in range(5):\n    print(\"Iteration:\", i)\n\n\nIteration: 0\nIteration: 1\nIteration: 2\nIteration: 3\nIteration: 4\n\n\n\n\nCode\n# While loop\nn = 0\nwhile n &lt; 3:\n    print(\"While loop iteration:\", n)\n    n += 1\n\n\nWhile loop iteration: 0\nWhile loop iteration: 1\nWhile loop iteration: 2\n\n\n\n\n2.1.1.5 Functions\nDefining and calling functions.\n\n\nCode\ndef add_numbers(a, b):\n    return a + b\n\nresult = add_numbers(5, 3)\nprint(\"Sum:\", result)\n\n\nSum: 8\n\n\n\n\n2.1.1.6 Basic Numerical Computations using NumPy\nNumPy is useful for numerical operations.\n\n\nCode\n#Solve 2x+3y=54x+4y=6\nimport numpy as np\n\nA = np.array([[2, 3], [4, 4]])\nb = np.array([5, 6])\n\nx = np.linalg.solve(A, b)\nprint(\"Solution:\", x)\n\n\nSolution: [-0.5  2. ]\n\n\n\n\n2.1.1.7 Plotting Graphs with Matplotlib\nMatplotlib is used for simple visualizations. Install using: pip install matplotlib\n\n\nCode\n#Plotting a sine wave \nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0, 10, 100)\ny = np.sin(x)\n\nplt.plot(x, y)\nplt.xlabel(\"x\")\nplt.ylabel(\"sin(x)\")\nplt.title(\"Sine Wave\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Parameters\nVs = 5.0  # Source voltage (Volts)\nR = 1000  # Resistance (Ohms)\nC = 1e-6  # Capacitance (Farads)\ntau = R * C # Time constant\n\n# Create a time vector from 0 to 5*tau\nt = np.linspace(0, 5 * tau, 100)\n\n# Calculate voltage using the formula\nVc = Vs * (1 - np.exp(-t / tau))\n\n# Plotting the result\nplt.figure(figsize=(8, 5))\nplt.plot(t, Vc, label=f'RC = {tau}s')\nplt.title('Capacitor Charging Voltage')\nplt.xlabel('Time (s)')\nplt.ylabel('Voltage (V)')\nplt.grid(True)\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2.1: Voltage across a charging capacitor in an RC circuit.\n\n\n\n\n\n\n\n2.1.1.8 Solution of PDE Using SciPy\nSciPy provides numerical solvers for differential equations and optimizations.\n\n\n\n\n\n\nInstalling Scipy\n\n\n\nThe Scipy library can be installed using the pip install scipy command in terminal or using !pip install scipy in colab.\n\n\n\n\nCode\n#Solving a Simple PDE ∂u/∂x + ∂u/∂t=0\nfrom sympy import symbols, Function, Eq, Derivative, pdsolve\n\n# Define variables\nx, t = symbols('x t')\nu = Function('u')(x, t)\n\n# Define a simple PDE: ∂u/∂x + ∂u/∂t = 0\npde = Eq(Derivative(u, x) + Derivative(u, t), 0)\n\n# Solve the PDE using pdsolve\nsolution = pdsolve(pde)\n# Print the solution\nprint(solution)\n\n\nEq(u(x, t), F(-t + x))\n\n\n\n\nCode\n# Example: Solving an ODE as an approximation for a PDE\nfrom scipy.integrate import solve_ivp\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef pde_rhs(t, u):\n    return -0.5 * u  # Example equation\n\nsol = solve_ivp(pde_rhs, [0, 10], [1], t_eval=np.linspace(0, 10, 100))\nplt.plot(sol.t, sol.y[0])\nplt.xlabel('Time')\nplt.ylabel('Solution')\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2.2: Solution of PDE.\n\n\n\n\n\n\n\n2.1.1.9 Basic Optimization Using SymPy\nSymPy is a symbolic mathematics library that can be used to derive analytical solutions to PDEs.\n\n\nCode\nfrom scipy.optimize import minimize\n\ndef objective(x):\n    return x**2 + 2*x + 1\n\nresult = minimize(objective, 0)  # Start search at x=0\nprint(\"Optimal x:\", result.x)\n\n\nOptimal x: [-1.00000001]",
    "crumbs": [
      "Fundamentals",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Lab Session 1: Python's Scientific Stack</span>"
    ]
  },
  {
    "objectID": "01-intro-python.html#practice-tasks",
    "href": "01-intro-python.html#practice-tasks",
    "title": "2  Lab Session 1: Python’s Scientific Stack",
    "section": "2.2 Practice tasks",
    "text": "2.2 Practice tasks\n\n2.2.1 T-1: Representing an Analog Signal\nConcept: In electronics, continuous analog signals (like AC voltage) are sampled at discrete time intervals to be processed by a digital system (like a microcontroller or computer). A NumPy array is the perfect way to store these sampled values.\nPython Skills: * np.linspace(): To create an array of evenly spaced time points. * np.sin(): An element-wise function that applies the sine function to every value in an array.\nTask: Generate and plot a 50 Hz sine wave voltage signal with a peak voltage of 5V, sampled for 3 cycles.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- Parameters ---\nfrequency = 50  # Hz\npeak_voltage = 5.0  # Volts\ncycles = 3\nsampling_rate = 1000 # Samples per second\n\n# --- Time Array Generation ---\n# Duration of 3 cycles is 3 * (1/frequency)\nduration = cycles / frequency \n# Create 1000 points per second * duration\nnum_samples = int(sampling_rate * duration)\nt = np.linspace(0, duration, num_samples)\n\n# --- Signal Generation ---\n# The formula for a sine wave is V(t) = V_peak * sin(2 * pi * f * t)\nvoltage = peak_voltage * np.sin(2 * np.pi * frequency * t)\n\n# --- Visualization ---\nplt.figure(figsize=(10, 4))\nplt.plot(t, voltage)\nplt.title('Digital Representation of a 50 Hz Sine Wave')\nplt.xlabel('Time (s)')\nplt.ylabel('Voltage (V)')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2.3: A 5V, 50 Hz sine wave sampled over time.\n\n\n\n\n\n\n\n2.2.2 T-2: Modeling a Noisy Sensor Reading\nConcept: Real-world sensor data is never perfect. It’s often corrupted by random noise. We can simulate this by adding a random component to our ideal signal.\nPython Skills: - Array Addition: Simply using + to add two arrays of the same shape.\n\nnp.random.normal(): To generate Gaussian noise, which is a common model for electronic noise.\n\nTask: Take the 5V sine wave from the previous example and add Gaussian noise with a standard deviation of 0.5V to simulate a noisy sensor reading.\n\n\nCode\n# We can reuse the 't' and 'voltage' arrays from the previous example\nnoise_amplitude = 0.5 # Standard deviation of the noise in Volts\n\n# Generate noise with the same shape as our voltage array\nnoise = np.random.normal(0, noise_amplitude, voltage.shape)\n\n# Create the noisy signal by adding the noise to the ideal signal\nnoisy_voltage = voltage + noise\n\n# --- Visualization ---\nplt.figure(figsize=(10, 4))\nplt.plot(t, voltage, label='Ideal Signal', linestyle='--')\nplt.plot(t, noisy_voltage, label='Noisy Sensor Reading', alpha=0.75)\nplt.title('Ideal vs. Noisy Signal')\nplt.xlabel('Time (s)')\nplt.ylabel('Voltage (V)')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2.4: Ideal sine wave vs. a simulated noisy sensor reading.\n\n\n\n\n\n\n\n2.2.3 T-3: Forward Kinematics of a 2-Link Robot Arm\nConcept: Forward kinematics in robotics is the process of calculating the position of the robot’s end-effector (e.g., its gripper) based on its joint angles. For a simple 2D arm, this involves basic trigonometry.\nPython Skills:\n\nUsing arrays to represent vectors (link lengths).\nUsing scalar variables for parameters (joint angles).\nBasic arithmetic and trigonometric functions (np.cos, np.sin, np.deg2rad).\n\nTask: Calculate and plot the position of a 2-link planar robot arm with link lengths L1=1.0m and L2=0.7m for given joint angles theta1=30° and theta2=45°.\n\n\nCode\n# --- Parameters ---\nL1 = 1.0  # Length of link 1\nL2 = 0.7  # Length of link 2\ntheta1_deg = 30\ntheta2_deg = 45\n\n# Convert angles to radians for numpy's trig functions\ntheta1 = np.deg2rad(theta1_deg)\ntheta2 = np.deg2rad(theta2_deg)\n\n# --- Kinematics Calculations ---\n# Position of the first joint (end of L1)\nx1 = L1 * np.cos(theta1)\ny1 = L1 * np.sin(theta1)\n\n# Position of the end-effector (end of L2) relative to the first joint\n# The angle of the second link is theta1 + theta2\nx2 = x1 + L2 * np.cos(theta1 + theta2)\ny2 = y1 + L2 * np.sin(theta1 + theta2)\n\n# --- Visualization ---\nplt.figure(figsize=(6, 6))\n# Plot the arm links\nplt.plot([0, x1], [0, y1], 'r-o', linewidth=3, markersize=10, label='Link 1')\nplt.plot([x1, x2], [y1, y2], 'b-o', linewidth=3, markersize=10, label='Link 2')\n\n# Plot the base and end-effector positions for clarity\nplt.plot(0, 0, 'ko', markersize=15, label='Base')\nplt.plot(x2, y2, 'gX', markersize=15, label='End-Effector')\n\nplt.title('2-Link Robot Arm Kinematics')\nplt.xlabel('X Position (m)')\nplt.ylabel('Y Position (m)')\nplt.grid(True)\nplt.axis('equal') # Important for correct aspect ratio\nplt.legend()\nplt.show()\n\nprint(f\"End-effector is at position: ({x2:.2f}, {y2:.2f})\")\n\n\n\n\n\n\n\n\nFigure 2.5: Position of a 2-link robot arm using forward kinematics.\n\n\n\n\n\nEnd-effector is at position: (1.05, 1.18)\n\n\n\n\n2.2.4 T-4: Rotating a Sensor’s Coordinate Frame\nConcept: A robot often has sensors (like a camera or a Lidar) mounted at an angle. To understand the sensor data in the robot’s own coordinate frame, we need to rotate the data points. This is a fundamental operation in robotics and computer vision, done using a rotation matrix.\nPython Skills:\n\nCreating a 2D NumPy array (a matrix).\nMatrix multiplication using the @operator.\nTransposing an array (.T) for correct multiplication dimensions.\n\nTask: A sensor detects an object at coordinates (2, 0) in its own frame. The sensor is rotated 45 degrees counter-clockwise relative to the robot’s base. Find the object’s coordinates in the robot’s frame.\n\n\nCode\n# Angle of the sensor relative to the robot\nangle_deg = 45\nangle_rad = np.deg2rad(angle_deg)\n\n# Point detected in the sensor's frame [x, y]\np_sensor = np.array([[2], [0]]) # As a column vector\n\n# 2D Rotation Matrix\n# R = [[cos(theta), -sin(theta)],\n#      [sin(theta),  cos(theta)]]\nR = np.array([[np.cos(angle_rad), -np.sin(angle_rad)],\n              [np.sin(angle_rad),  np.cos(angle_rad)]])\n\n# The transformation: p_robot = R @ p_sensor\np_robot = R @ p_sensor\n\n# --- Visualization ---\nplt.figure(figsize=(6, 6))\n# Plot sensor's axes\nplt.quiver(0, 0, np.cos(angle_rad), np.sin(angle_rad), color='r', scale=3, label=\"Sensor x'-axis\")\nplt.quiver(0, 0, -np.sin(angle_rad), np.cos(angle_rad), color='g', scale=3, label=\"Sensor y'-axis\")\n\n# Plot the point in the robot's frame\nplt.plot(p_robot[0], p_robot[1], 'bo', markersize=10, label='Point in Robot Frame')\n# For context, let's show where the point was in the sensor's frame (if it weren't rotated)\n# This is just for visualization\nplt.plot(p_sensor[0], p_sensor[1], 'ko', markersize=10, alpha=0.5, label='Original point (relative to axes)')\n\n\nplt.axhline(0, color='black', linewidth=0.5)\nplt.axvline(0, color='black', linewidth=0.5)\nplt.grid(True)\nplt.axis('equal')\nplt.xlim(-1, 3)\nplt.ylim(-1, 3)\nplt.title(\"Coordinate Frame Rotation\")\nplt.xlabel(\"Robot X-axis\")\nplt.ylabel(\"Robot Y-axis\")\nplt.legend()\nplt.show()\n\nprint(\"Rotation Matrix:\\n\", np.round(R, 2))\nprint(f\"\\nPoint in Sensor Frame: {p_sensor.flatten()}\")\nprint(f\"Point in Robot Frame:  {np.round(p_robot.flatten(), 2)}\")\n\n\n\n\n\n\n\n\nFigure 2.6: Rotating a point from a sensor’s frame to the robot’s frame.\n\n\n\n\n\nRotation Matrix:\n [[ 0.71 -0.71]\n [ 0.71  0.71]]\n\nPoint in Sensor Frame: [2 0]\nPoint in Robot Frame:  [1.41 1.41]\n\n\n\n\n2.2.5 T-5: Applying a Simple Digital Filter\nConcept: To clean up the noisy signal from Example 3, we can apply a digital filter. The simplest is a moving average filter, which replaces each data point with the average of itself and its neighbors. This smooths out sharp fluctuations (noise).\nPython Skills:\n\nLooping over an array.\nArray slicing: array[start:end].\nnp.mean(): To calculate the average of a set of numbers.\n\nTask: Apply a 5-point moving average filter to the noisy_voltage signal created in Example 3 and plot the result to see the smoothing effect.\n\n\nCode\n# Let's regenerate the noisy signal for a self-contained example\n# (In a real notebook, you would reuse the variable from before)\nfrequency = 50\npeak_voltage = 5.0\nduration = 3 / frequency\nt = np.linspace(0, duration, int(1000 * duration))\nvoltage = peak_voltage * np.sin(2 * np.pi * frequency * t)\nnoise = np.random.normal(0, 0.5, voltage.shape)\nnoisy_voltage = voltage + noise\n\n# --- Filtering ---\nwindow_size = 5\n# Create an empty array to store the filtered signal\nfiltered_voltage = np.zeros_like(noisy_voltage)\n\n# Loop through the signal. We can't compute a full window at the very edges,\n# so we'll just copy the original values for the first and last few points.\nfor i in range(len(noisy_voltage)):\n    # Find the start and end of the slice\n    start = max(0, i - window_size // 2)\n    end = min(len(noisy_voltage), i + window_size // 2 + 1)\n    \n    # Get the window of data and calculate its mean\n    window = noisy_voltage[start:end]\n    filtered_voltage[i] = np.mean(window)\n\n# --- Visualization ---\nplt.figure(figsize=(10, 4))\nplt.plot(t, noisy_voltage, label='Noisy Signal', alpha=0.5)\nplt.plot(t, filtered_voltage, label='Filtered Signal', color='r', linewidth=2)\nplt.title('Effect of Moving Average Filter')\nplt.xlabel('Time (s)')\nplt.ylabel('Voltage (V)')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2.7: Noisy signal smoothed using a 5-point moving average filter.",
    "crumbs": [
      "Fundamentals",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Lab Session 1: Python's Scientific Stack</span>"
    ]
  },
  {
    "objectID": "02-pde-numerical.html",
    "href": "02-pde-numerical.html",
    "title": "3  Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)",
    "section": "",
    "text": "3.1 Experiment 2: 1D Wave Equation (The Advection Equation)\nWhile Experiment 1 dealt with basic python programming and solution of a parabolic PDE (diffusion), this experiment focuses on a hyperbolic PDE, which describes phenomena that propagate, like waves. We will solve the 1D Linear Advection Equation, a fundamental model for wave motion.\nGoverning Equation: \\[ \\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = 0 \\]\nHere, u(x, t) is the quantity that is moving (e.g., the height of a water wave or the stress in a rod), x is position, t is time, and c is the constant speed at which the wave travels.",
    "crumbs": [
      "Partial Differential Equations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)</span>"
    ]
  },
  {
    "objectID": "02-pde-numerical.html#experiment-2-1d-wave-equation-the-advection-equation",
    "href": "02-pde-numerical.html#experiment-2-1d-wave-equation-the-advection-equation",
    "title": "3  Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)",
    "section": "",
    "text": "3.1.1 Aim\nTo solve the one-dimensional wave equation using the Upwind Method and compare the numerical result with the initial condition.\n\n\n3.1.2 Objectives\n\nTo learn how to solve partial differential equations using numerical methods.\nTo understand and apply the Finite Difference Method for hyperbolic equations.\nTo observe how a wave profile moves with time.\nTo write and run a Python program for the simulation.\n\n\n\n3.1.3 The Upwind Method Algorithm\nThe “upwind” name comes from the fact that for a wave moving to the right (c &gt; 0), we use information from the “upwind” direction (the left side, i-1) to determine the state at the next time step.\n\nDiscretize Domain: Set the number of space points (nx) and time steps (nt). Define the domain length (Lx) and total time (T). Calculate the step sizes \\(dx = \\dfrac{Lx}{(nx - 1)}\\) and \\(dt = \\dfrac{T}{nt}\\).\nCheck Stability (CFL Condition): Compute the Courant-Friedrichs-Lewy (CFL) number, \\(\\lambda = c \\frac{\\Delta t}{\\Delta x}\\). For the explicit upwind scheme to be stable, we must have \\(\\lambda \\le 1\\). This means the numerical wave speed (dx/dt) must be faster than the physical wave speed (c), so the calculation can “keep up” with the phenomenon.\nSet Initial Condition: Define the initial shape of the wave, u(x, 0).\nTime Marching Loop: For each time step n, iterate through all spatial points i and apply the upwind formula to find the wave’s new state u_new. The discretized formula is: \\[ u_i^{n+1} = u_i^n - \\lambda (u_i^n - u_{i-1}^n) \\]\nUpdate: Set u = u_new.\nVisualize: Plot the final wave profile against the initial one.\n\n\n\n3.1.4 Case Study: Exponential Decay Wave\nLet’s simulate the equation \\(\\frac{\\partial u}{\\partial t} + \\frac{\\partial u}{\\partial x} = 0\\) (so c=1) with the initial condition \\(u(x, 0) = e^{-x}\\).\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- 1. Discretize Domain ---\nnx = 50       # Number of spatial points\nnt = 30       # Number of time steps\nLx = 5.0      # Domain length\nT = 2.0       # Total time\ndx = Lx / (nx - 1)  # Spatial step\ndt = T / nt         # Time step\n\nc = 1.0       # Wave speed\n\n# --- 2. Check Stability ---\nlambda_ = c * dt / dx\nprint(f\"CFL Number (lambda) = {lambda_:.4f}\")\nif lambda_ &gt; 1:\n    print(\"Warning: CFL condition not met. The solution may be unstable!\")\n\n# --- 3. Set Initial Condition ---\nx = np.linspace(0, Lx, nx)\nu = np.exp(-x)  # u(x, 0) = e^(-x)\nu_initial = u.copy() # Save the initial state for plotting\n\n# --- 4. & 5. Time Marching Loop ---\nfor n in range(nt):\n    u_old = u.copy()\n    # Apply upwind formula to all interior points\n    for i in range(1, nx):\n        u[i] = u_old[i] - lambda_ * (u_old[i] - u_old[i-1])\n\n# --- 6. Visualize ---\nplt.figure(figsize=(10, 6))\nplt.plot(x, u_initial, 'r--', label=\"Initial Condition at t=0\")\nplt.plot(x, u, 'b-', marker='o', markersize=4, label=f\"Numerical Solution at t={T}\")\nplt.xlabel(\"Position (x)\")\nplt.ylabel(\"u(x, t)\")\nplt.legend()\nplt.title(\"Solution of 1D Advection Equation (Upwind Scheme)\")\nplt.grid(True)\nplt.show()\n\n\nCFL Number (lambda) = 0.6533\n\n\n\n\n\n\n\n\nFigure 3.1: Numerical solution of the advection equation with an exponential initial condition using the Upwind scheme.\n\n\n\n\n\n\n\n3.1.5 Result and Discussion\nThe numerical solution using the Upwind Method for the initial condition \\(u(x,0)=e^{-x}\\) shows the wave propagating to the right, as expected. The Courant number \\(\\lambda=c\\dfrac{dt}{dx}\\) was maintained within the stability range (\\(\\lambda\\leq 1\\)), ensuring a stable and oscillation-free result. However, we can observe two key phenomena characteristic of this first-order scheme:\n\nNumerical Diffusion: The final wave shape is “smeared” or smoothed out compared to the initial condition. The sharp features are dampened. This is artificial damping introduced by the numerical method itself.\nAmplitude Decay: The peak of the wave seems to decrease slightly.\n\nDespite these inaccuracies, the upwind scheme is computationally simple and robust, making it effective for simulating basic convection phenomena where the general transport behavior is more important than preserving the exact shape of the wave.",
    "crumbs": [
      "Partial Differential Equations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)</span>"
    ]
  },
  {
    "objectID": "02-pde-numerical.html#application-problem-stress-wave-in-a-rod",
    "href": "02-pde-numerical.html#application-problem-stress-wave-in-a-rod",
    "title": "3  Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)",
    "section": "3.2 Application Problem: Stress Wave in a Rod",
    "text": "3.2 Application Problem: Stress Wave in a Rod\nIn mechanical systems, like long slender rods or beams, stress waves travel due to sudden loads or impacts. When a rod is struck at one end, a wave of stress and strain travels along its length. This can be modeled using the same 1D advection equation.\nTask: Modify the code above to simulate a “square pulse” stress wave.\nGoverning Equation: \\(\\frac{\\partial u}{\\partial t}+c\\frac{\\partial u}{\\partial t}=0\\).\nInitial Condition: A square pulse representing a localized impact.\n\\[u(x,0)=\\begin{cases} 1&; 0.4\\leq x\\leq 0.6\\\\ 0&; \\text{otherwise}\\end{cases}\\]\nYour Challenge:\n\nCopy the Python code block from the previous example.\nChange the line that sets the initial condition u to create the square pulse described above. Hint: You can use NumPy’s logical indexing. For example: u[ (x &gt;= 0.4) & (x &lt;= 0.6) ] = 1.0. You will need to initialize u as an array of zeros first: u = np.zeros(nx).\nRe-run the simulation. Observe how the sharp corners of the square wave are smoothed out due to numerical diffusion.\n\n\n3.2.0.1 Solution to the Application Problem: Stress Wave in a Rod\nHere, we apply the same Upwind Method to the practical problem of a stress wave propagating through a mechanical rod. The initial condition is a square pulse, which could represent a short, sharp impact from a hammer strike on a specific section of the rod.\n\nPython Implementation\n\nThe core algorithm remains the same. The only change is in how we define the initial condition u(x, 0).\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- 1. Discretize Domain (same as before) ---\nnx = 101      # Increased points for better resolution\nnt = 50       # Increased time steps\nLx = 2.0      # Longer domain to see the wave travel\nT = 1.0       # Total time\ndx = Lx / (nx - 1)\ndt = T / nt\nc = 1.0       # Wave speed\n\n# --- 2. Check Stability ---\nlambda_ = c * dt / dx\nprint(f\"CFL Number (lambda) = {lambda_:.4f}\")\nif lambda_ &gt; 1:\n    print(\"Warning: CFL condition not met. The solution may be unstable!\")\n\n# --- 3. Set Initial Condition: Square Pulse ---\nx = np.linspace(0, Lx, nx)\n# Initialize u as an array of zeros\nu = np.zeros(nx)\n# Set the pulse region to 1.0 using logical indexing\nu[(x &gt;= 0.4) & (x &lt;= 0.6)] = 1.0\n\n# Save the initial state for plotting\nu_initial = u.copy()\n\n# --- 4. & 5. Time Marching Loop (same as before) ---\nfor n in range(nt):\n    u_old = u.copy()\n    for i in range(1, nx):\n        u[i] = u_old[i] - lambda_ * (u_old[i] - u_old[i-1])\n\n# --- 6. Visualize ---\n# Calculate the analytical solution's position for comparison\n# The pulse should have moved by a distance of c*T\nanalytical_x_start = 0.4 + c * T\nanalytical_x_end = 0.6 + c * T\n\nplt.figure(figsize=(10, 6))\nplt.plot(x, u_initial, 'r--', label=\"Initial Condition (t=0)\")\nplt.plot(x, u, 'b-', marker='.', markersize=5, label=f\"Numerical Solution (t={T})\")\n\n# Plot the theoretical \"perfect\" wave for comparison\nplt.plot([analytical_x_start, analytical_x_end], [1, 1], 'g:', linewidth=3, label=f'Analytical Position (t={T})')\nplt.plot([analytical_x_start, analytical_x_start], [0, 1], 'g:', linewidth=3)\nplt.plot([analytical_x_end, analytical_x_end], [0, 1], 'g:', linewidth=3)\n\n\nplt.xlabel(\"Position along rod (x)\")\nplt.ylabel(\"Stress/Strain (u)\")\nplt.ylim(-0.2, 1.2) # Set y-axis limits for better visualization\nplt.legend()\nplt.title(\"Simulation of a Square Stress Wave\")\nplt.grid(True)\nplt.show()\n\n\nCFL Number (lambda) = 1.0000\n\n\n\n\n\n\n\n\nFigure 3.2: Propagation of a square pulse stress wave, showing significant numerical diffusion.\n\n\n\n\n\n\n\n3.2.0.2 Discussion of the Square Pulse Result\nWave Propagation: The primary success of the simulation is clearly visible: the pulse has moved to the right. The leading edge of the numerical solution is centered around the correct analytical position (x = 1.4 for the start of the pulse), confirming that the model correctly captures the fundamental advection behavior at speed c=1 over time T=1.\nNumerical Diffusion: The most striking feature of the result is the severe smoothing of the square pulse. The sharp, vertical edges of the initial condition have been transformed into gentle slopes. The flat top of the pulse has become rounded and its peak amplitude has decreased from 1.0 to approximately 0.75. This is a classic and pronounced example of numerical diffusion, an error inherent in the first-order upwind scheme. The scheme struggles to resolve sharp gradients (discontinuities), so it effectively “smears” them out over several grid points.\nPractical Implications: In a real engineering scenario, if we needed to know the exact peak stress and its precise location, this simple method would be inadequate. The predicted peak stress is significantly lower than the actual initial stress, which could lead to an incorrect safety assessment.\nImproving the Model: While the upwind scheme is simple, its diffusive nature is a major drawback for problems requiring high accuracy. To improve the result and preserve the sharpness of the wave, engineers would use:\n\nHigher-Order Schemes: Methods like the Lax-Wendroff scheme or flux-limiter methods are designed to be less diffusive and capture sharp fronts more accurately.\nFiner Grid: Reducing dx and dt (while keeping lambda stable) can decrease the amount of diffusion, but at a significant computational cost.\n\n\n\n3.2.0.3 Result\nThe application simulation successfully models the physical propagation of a stress wave. However, it also serves as a crucial lesson in computational engineering: every numerical method has inherent errors and limitations. The Upwind Method, while stable and simple, introduces significant numerical diffusion that must be considered when interpreting the results.",
    "crumbs": [
      "Partial Differential Equations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)</span>"
    ]
  },
  {
    "objectID": "02-pde-numerical.html#experiment-3-solving-the-1d-heat-equation",
    "href": "02-pde-numerical.html#experiment-3-solving-the-1d-heat-equation",
    "title": "3  Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)",
    "section": "3.3 Experiment 3: Solving the 1D Heat Equation",
    "text": "3.3 Experiment 3: Solving the 1D Heat Equation\nThis experiment introduces the numerical solution of a parabolic partial differential equation: the one-dimensional heat equation. This equation is fundamental to understanding diffusion processes, not just in heat transfer but also in chemical concentration gradients and other physical phenomena.\n\n3.3.1 Aim\nTo solve the one-dimensional heat conduction equation using the Finite Difference Method (explicit scheme) in Python and to visualize the temperature distribution over time.\n\n\n3.3.2 Objectives\n\nTo understand the physical interpretation of the one-dimensional heat equation.\nTo discretize the heat equation using the Forward Time Centred Space (FTCS) scheme.\nTo implement the finite difference method in Python.\nTo analyze the stability condition required for this numerical method.\nTo visualize the temperature profiles at different time levels.\n\n\n\n3.3.3 Governing Equation and Discretization\nThe one-dimensional heat equation describes how temperature u evolves at a position x and time t. It is given by:\n\\[\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}\n\\]\nwhere \\(\\alpha\\) is the thermal diffusivity of the material, a constant that indicates how quickly the material conducts heat.\nTo solve this numerically, we use the FTCS method. We approximate the derivatives with finite differences: * Time Derivative (Forward Difference): \\(\\frac{\\partial u}{\\partial t} \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}\\) * Space Derivative (Centred Difference): \\(\\frac{\\partial^2 u}{\\partial x^2} \\approx \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2}\\)\nHere, the superscript n denotes the time level and the subscript i denotes the spatial grid point. Substituting these into the governing equation and rearranging for the future temperature \\(u_i^{n+1}\\), we get the explicit update formula.\n\n\n3.3.4 Algorithm\n\nInitialize Parameters: Set the values for the rod length L, total simulation time T, number of spatial nodes \\(n_x\\), number of time steps \\(n_t\\), and thermal diffusivity \\(\\alpha\\).\nDiscretize the Domain: Calculate the step sizes for space and time.\n\nSpace step: \\(\\Delta x = \\frac{L}{n_x - 1}\\)\nTime step: \\(\\Delta t = \\frac{T}{n_t}\\)\n\nCheck Stability Condition: Calculate the stability parameter, r. For the FTCS scheme to be stable and produce a physically realistic result, this value must be less than or equal to 0.5. \\[\nr = \\frac{\\alpha \\Delta t}{(\\Delta x)^2} \\le 0.5\n\\]\nSet Initial and Boundary Conditions:\n\nDefine the initial temperature distribution along the rod, \\(u(x, 0)\\).\nApply boundary conditions. In this case, we use Dirichlet boundary conditions, which means the temperature at the ends of the rod is fixed for all time (e.g., \\(u(0, t) = u(L, t) = 0\\)).\n\nIterate Over Time: For each time step n, loop through all the interior spatial points i and update their temperature using the FTCS formula: \\[\nu_i^{n+1} = u_i^n + r \\left( u_{i+1}^n - 2u_i^n + u_{i-1}^n \\right)\n\\]\nOutput and Visualization: Store the temperature profiles at different time intervals and plot them to visualize the heat diffusion process.\n\n\n\n3.3.5 Sample Problem and Python Implementation\nProblem: Solve the 1D heat equation on a rod of length L=1.0 m with the following conditions: The temperature is zero everywhere except at the very center, where an initial “heat pulse” of 100°C is applied. The ends of the rod are kept at a constant 0°C for all time.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- 1. Initialize Parameters ---\nL = 1.0           # Length of the rod (meters)\nT = 0.1           # Total simulation time (seconds)\nnx = 21           # Number of spatial grid points (use an odd number for a perfect center)\nnt = 1000         # Number of time steps\nalpha = 0.01      # Thermal diffusivity (e.g., for copper)\n\n# --- 2. Discretize the Domain ---\ndx = L / (nx - 1)             # Space step size\ndt = T / nt                   # Time step size\n\n# --- 3. Check Stability Condition ---\nr = alpha * dt / dx**2\nprint(f\"Space step dx = {dx:.4f} m\")\nprint(f\"Time step dt = {dt:.4f} s\")\nprint(f\"Stability parameter r = {r:.4f}\")\nif r &gt; 0.5:\n    print(\"\\n--- WARNING: STABILITY CONDITION r &gt; 0.5 NOT MET! ---\")\n    print(\"The solution is likely to be unstable and blow up.\")\nelse:\n    print(\"\\nStability condition r &lt;= 0.5 is satisfied.\")\n\n\n# --- 4. Set Initial and Boundary Conditions ---\n# Spatial grid\nx = np.linspace(0, L, nx)\n\n# Initial condition: temperature distribution is zero everywhere...\nu = np.zeros(nx)\n# ...except for a pulse at the center.\nu[int((nx - 1) / 2)] = 100\n\n# Boundary conditions u(0,t)=0 and u(L,t)=0 are enforced by the loop range (1, nx-1)\n\n# --- 5. & 6. Time-stepping and Output ---\n# To store results at different time steps for plotting\nu_snapshots = [u.copy()]\nsnapshot_interval = 200 # Store a snapshot every 200 time steps\n\nfor n in range(nt):\n    u_old = u.copy()\n    # Loop over interior points to apply the FTCS formula\n    for i in range(1, nx - 1):\n        u[i] = u_old[i] + r * (u_old[i+1] - 2*u_old[i] + u_old[i-1])\n\n    # Store a snapshot of the solution at specified intervals\n    if (n + 1) % snapshot_interval == 0:\n        u_snapshots.append(u.copy())\n\n# --- Plotting the results ---\nplt.figure(figsize=(10, 6))\nfor i, u_snap in enumerate(u_snapshots):\n    time = i * snapshot_interval * dt\n    plt.plot(x, u_snap, label=f't = {time:.2f} s')\n\nplt.xlabel('Position along rod (x)')\nplt.ylabel('Temperature (°C)')\nplt.title('1D Heat Equation: Explicit FTCS Method')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\nSpace step dx = 0.0500 m\nTime step dt = 0.0001 s\nStability parameter r = 0.0004\n\nStability condition r &lt;= 0.5 is satisfied.\n\n\n\n\n\n\n\n\nFigure 3.3: Diffusion of a central heat pulse over time, calculated with the FTCS explicit method.",
    "crumbs": [
      "Partial Differential Equations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)</span>"
    ]
  },
  {
    "objectID": "02-pde-numerical.html#application-challenge-heat-dissipation-in-a-longer-rod",
    "href": "02-pde-numerical.html#application-challenge-heat-dissipation-in-a-longer-rod",
    "title": "3  Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)",
    "section": "3.4 Application Challenge: Heat Dissipation in a Longer Rod",
    "text": "3.4 Application Challenge: Heat Dissipation in a Longer Rod\nNow, let’s apply what you’ve learned to a new set of physical parameters. This exercise simulates heat dissipation in a longer structural beam with a more intense initial heat source.\n\nYour Task\n\nSimulate the 1D heat equation on a rod with the following new conditions:\n\nRod Length (L): 3.2 meters\nInitial Condition: The temperature is 0°C everywhere except for a single point at the very center, which has an intense initial temperature of 300°C.\nBoundary Conditions: The ends of the rod are maintained at 0°C (Dirichlet BC).\nMaterial: Assume the same thermal diffusivity, \\(\\alpha = 0.01\\).\nSimulation Time (T): Run the simulation for a longer time, T = 2.0 seconds, to observe more significant diffusion.\n\n\nThe Challenge\n\n\nCopy the Python code from the previous example.\nModify the parameter values (L, T, and the initial temperature pulse).\nCrucially, after changing L and T, you must re-calculate the stability parameter r. If r &gt; 0.5, the simulation will fail! You will need to adjust either nx (number of space points) or nt (number of time steps) to bring r back into the stable region (\\(\\le 0.5\\)). The goal is to find a stable combination.\n\n\nHint: The stability parameter is \\(r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}\\).\n\n\nIf your r value is too high, you have two options to decrease it:\nIncrease nt: This makes the time step Δt smaller, which is the most direct way to lower r.\nDecrease nx: This makes the space step Δx larger. While this also works, it reduces the spatial resolution of your simulation.\n\nTry increasing nt first. A good starting point would be to double it until r is stable.\n\nSolution to the Application Challenge\n\nHere is the complete Python code implementing the solution for the new parameters. The key is adjusting nt to ensure stability.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- 1. Initialize MODIFIED Parameters ---\nL = 3.2           # New Length of the rod (meters)\nT = 2.0           # New Total simulation time (seconds)\nnx = 51           # Number of spatial grid points (odd for a center)\n# nt must be adjusted for stability. Let's start with a high value.\nnt = 8000\nalpha = 0.01      # Thermal diffusivity\n\n# --- 2. Discretize the Domain ---\ndx = L / (nx - 1)\ndt = T / nt\n\n# --- 3. Check Stability Condition ---\nr = alpha * dt / dx**2\nprint(f\"--- Challenge Parameters ---\")\nprint(f\"Rod Length L = {L} m\")\nprint(f\"Space step dx = {dx:.4f} m\")\nprint(f\"Time step dt = {dt:.6f} s\")\nprint(f\"Stability parameter r = {r:.4f}\")\n\nif r &gt; 0.5:\n    required_nt = (alpha * T * (nx - 1)**2) / (0.5 * L**2)\n    print(f\"\\n--- WARNING: STABILITY FAILED (r &gt; 0.5) ---\")\n    print(f\"With nx={nx}, you need at least nt = {int(np.ceil(required_nt))} to achieve stability.\")\nelse:\n    print(\"\\nStability condition r &lt;= 0.5 is satisfied.\")\n\n\n# --- 4. Set Initial and Boundary Conditions ---\nx = np.linspace(0, L, nx)\nu = np.zeros(nx)\n# Set the new initial temperature pulse at the center\nu[int((nx - 1) / 2)] = 300.0\n\n# --- 5. & 6. Time-stepping and Output ---\nu_snapshots = [u.copy()]\nsnapshot_interval = nt // 4 # Store 4 snapshots over the total time\n\nfor n in range(nt):\n    u_old = u.copy()\n    for i in range(1, nx - 1):\n        u[i] = u_old[i] + r * (u_old[i] + u_old[i-1] - 2*u_old[i]) # Corrected formula\n\n    if (n + 1) % snapshot_interval == 0:\n        u_snapshots.append(u.copy())\n\n# --- Plotting the results ---\nplt.figure(figsize=(10, 6))\nfor i, u_snap in enumerate(u_snapshots):\n    time = i * snapshot_interval * dt\n    # The first plot is the initial condition at t=0\n    if i == 0:\n        time = 0.0\n    plt.plot(x, u_snap, label=f't = {time:.2f} s')\n\nplt.xlabel('Position along rod (x) [m]')\nplt.ylabel('Temperature (°C)')\nplt.title('Challenge: Heat Dissipation in a 3.2m Rod')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n--- Challenge Parameters ---\nRod Length L = 3.2 m\nSpace step dx = 0.0640 m\nTime step dt = 0.000250 s\nStability parameter r = 0.0006\n\nStability condition r &lt;= 0.5 is satisfied.\n\n\n\n\n\n\n\n\nFigure 3.4: Heat diffusion from a 300°C pulse in a 3.2m rod over 2.0 seconds.\n\n\n\n\n\n\n3.4.0.1 Results and Discussion of the Challenge\n\nStability Management: The primary challenge was maintaining stability. By increasing the rod length L significantly, the space step Δx became larger. Since Δx is squared in the denominator of the stability parameter r, this drastically increased the tendency for r to be large. To counteract this, the number of time steps nt had to be substantially increased (to 8000 in this solution) to make Δt small enough to keep r below the 0.5 threshold. This is a critical lesson in numerical methods: changing one parameter often necessitates adjusting others to maintain a valid simulation.\nSlower Diffusion: Comparing the plots to the first example, we can see that even though the simulation ran for a much longer time (2.0s vs 0.1s), the heat has not reached the ends of the rod. This is because the rod is much longer (3.2m vs 1.0m). Heat diffusion is a relatively slow process, and the increased distance means it takes significantly more time for the thermal energy to propagate.\nAmplitude and Profile: The initial peak temperature of 300°C drops very quickly, as the heat immediately begins to flow into the adjacent, colder sections of the rod. The resulting temperature profiles are wider and flatter compared to the first example at equivalent early stages, which is characteristic of diffusion over a larger domain.\n\nResult\nThe overall behavior remains physically consistent, demonstrating the robustness of the FTCS method when its stability condition is respected.",
    "crumbs": [
      "Partial Differential Equations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)</span>"
    ]
  },
  {
    "objectID": "02-pde-numerical.html#experiment-4-the-second-order-1d-wave-equation",
    "href": "02-pde-numerical.html#experiment-4-the-second-order-1d-wave-equation",
    "title": "3  Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)",
    "section": "3.5 Experiment 4: The Second-Order 1D Wave Equation",
    "text": "3.5 Experiment 4: The Second-Order 1D Wave Equation\nThis experiment moves from first-order to second-order hyperbolic PDEs by tackling the classic one-dimensional wave equation. This equation models a vast range of physical phenomena, including the vibrations of a guitar string, pressure waves in a tube, and the propagation of electromagnetic waves in a transmission line.\n\n3.5.1 Aim\nTo solve the one-dimensional wave equation using the finite difference method with an explicit time-stepping scheme.\n\n\n3.5.2 Objectives\n\nTo solve the second-order wave equation for a 1D domain with given initial and boundary conditions.\nTo implement the central difference scheme for both time and space derivatives.\nTo understand the role of initial displacement and initial velocity.\nTo simulate wave propagation and reflection and observe how waves evolve over time.\n\n\n\n3.5.3 Governing Equation and Discretization\nThe second-order, one-dimensional wave equation is given by: \\[\n\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\n\\] where \\(u(x,t)\\) is the displacement at position x and time t, and c is the constant wave propagation speed.\nTo solve this numerically, we use a central difference approximation for both derivatives: * Time Derivative: \\(\\frac{\\partial^2 u}{\\partial t^2} \\approx \\frac{u_i^{n+1} - 2u_i^n + u_i^{n-1}}{(\\Delta t)^2}\\) * Space Derivative: \\(\\frac{\\partial^2 u}{\\partial x^2} \\approx \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2}\\)\nSubstituting these into the governing equation and solving for the future displacement \\(u_i^{n+1}\\) gives the explicit update formula.\n\n\n3.5.4 Algorithm\n\nDiscretize the Domain:\n\nDivide the spatial domain of length L into discrete points using a step size \\(\\Delta x\\).\nDivide the time domain of total duration T using a time step \\(\\Delta t\\).\n\nStability Check (CFL Condition):\n\nCalculate the Courant Number, \\(C = \\frac{c \\Delta t}{\\Delta x}\\).\nFor this explicit scheme to be stable, the Courant number must satisfy \\(C \\le 1\\). If \\(C &gt; 1\\), the numerical solution will grow without bound and become meaningless.\n\nSet Initial Conditions:\n\nThis is a second-order equation in time, so we need two initial conditions:\n\nInitial displacement: \\(u(x, 0) = f(x)\\)\nInitial velocity: \\(\\frac{\\partial u}{\\partial t}(x, 0) = g(x)\\)\n\n\nSet Boundary Conditions:\n\nAssume the boundaries of the domain are fixed (e.g., the ends of a guitar string). This is a Dirichlet boundary condition: \\(u(0, t) = u(L, t) = 0\\) for all time t.\n\nTime-stepping Loop:\n\nThe update rule requires information from two previous time steps (n and n-1). This poses a problem for the very first step (n=1), as we don’t have a state at n=-1. We use a special formula for the first step derived from the initial velocity condition. For zero initial velocity, this simplifies.\nFor all subsequent time steps (n &gt; 1), use the main finite difference formula: \\[\nu_i^{n+1} = 2u_i^n - u_i^{n-1} + C^2 \\left( u_{i+1}^n - 2u_i^n + u_{i-1}^n \\right)\n\\]\n\nPlot and Visualize:\n\nAfter solving for all time steps, plot the wave’s displacement u(x) at different time instances to observe its motion and reflection.\n\n\n\n\n3.5.5 Application Problem and Python Implementation\nProblem: The vibration of a stretched string under tension is governed by the 1D wave equation. We are tasked with modeling the vibration of a string of length L=1.0m stretched between two fixed points. The string is given an initial displacement in the shape of a sine wave, \\(u(x,0) = \\sin(\\pi x)\\), but zero initial velocity.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- 1. Parameters & Discretization ---\nL = 1.0             # Length of the domain (string)\nc = 1.0             # Wave speed\ndx = 0.1            # Spatial step size\ndt = 0.05           # Time step size\nT = 2.0             # Total time (enough for one full reflection)\n\n# --- 2. Stability Check ---\nC = c * dt / dx\nprint(f\"Courant Number C = {C:.2f}\")\nif C &gt; 1:\n    raise ValueError(\"CFL condition (C &lt;= 1) not met. Instability expected.\")\nelse:\n    print(\"CFL condition is satisfied.\")\n\n# --- Grid setup ---\nx = np.arange(0, L + dx, dx)\nnx = len(x)\nnt = int(T / dt) + 1\n# Create a 2D array to store the solution at all time steps\nu = np.zeros((nt, nx))\n\n# --- 3. Initial Conditions ---\n# Initial displacement: u(x, 0) = sin(pi * x)\nu[0, :] = np.sin(np.pi * x)\n\n# Special formula for the first time step (n=1) assuming zero initial velocity\n# u_i^1 = u_i^0 + C^2/2 * (u_{i+1}^0 - 2u_i^0 + u_{i-1}^0)\nu[1, 1:-1] = u[0, 1:-1] + 0.5 * C**2 * (u[0, 2:] - 2*u[0, 1:-1] + u[0, :-2])\n# Boundary conditions u(0,t)=0 and u(L,t)=0 are already handled by slicing [1:-1]\n\n# --- 5. Time-stepping Loop ---\nfor n in range(1, nt - 1):\n    u[n + 1, 1:-1] = (2 * u[n, 1:-1] - u[n - 1, 1:-1] +\n                      C**2 * (u[n, 2:] - 2 * u[n, 1:-1] + u[n, :-2]))\n# Print results\nprint(\"x\\t\" + \"\\t\".join([f\"u^{n}\" for n in range(5)]))  # First 5 steps\nfor i in range(nx):\n    values = \"\\t\".join(f\"{u[n, i]:.4f}\" for n in range(5))\n    print(f\"{x[i]:.2f}\\t{values}\")\n# Optional: plot final wave\n# --- 6. Plot and Visualize ---\nplt.figure(figsize=(10, 6))\nplt.plot(x, u[0, :], 'r--', label='Initial (t=0)')\n# Time index for t = T/2\nmid_time_index = int(nt / 2)\nplt.plot(x, u[mid_time_index, :], 'g:', label=f'Mid-time (t={mid_time_index*dt:.2f}s)')\nplt.plot(x, u[-1, :], 'b-', label=f'Final (t={T:.2f}s)')\n\nplt.xlabel('Position along string (x)')\nplt.ylabel('Displacement (u)')\nplt.title('1D Wave Equation: Vibrating String Simulation')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\nCourant Number C = 0.50\nCFL condition is satisfied.\nx   u^0 u^1 u^2 u^3 u^4\n0.00    0.0000  0.0000  0.0000  0.0000  0.0000\n0.10    0.3090  0.3052  0.2940  0.2755  0.2504\n0.20    0.5878  0.5806  0.5592  0.5241  0.4762\n0.30    0.8090  0.7991  0.7697  0.7214  0.6554\n0.40    0.9511  0.9394  0.9048  0.8480  0.7705\n0.50    1.0000  0.9878  0.9514  0.8917  0.8102\n0.60    0.9511  0.9394  0.9048  0.8480  0.7705\n0.70    0.8090  0.7991  0.7697  0.7214  0.6554\n0.80    0.5878  0.5806  0.5592  0.5241  0.4762\n0.90    0.3090  0.3052  0.2940  0.2755  0.2504\n1.00    0.0000  0.0000  0.0000  0.0000  0.0000\n\n\n\n\n\n\n\n\nFigure 3.5: Vibration of a string with an initial sine-wave displacement, showing reflection.\n\n\n\n\n\n\n3.5.5.1 Result and Discussion\nThe simulation effectively models the behavior of a vibrating string with fixed ends.\n\nInitial State (t=0): The string starts in its initial sine wave shape, as defined.\nPropagation and Reflection: At the mid-time point (t=1.0s), the wave has traveled, reflected off the fixed boundaries, and become inverted. This is physically accurate: when a wave on a string hits a fixed end, it reflects back with opposite polarity.\nFinal State (t=2.0s): After one full period of oscillation, the wave has traveled to both ends, reflected, and returned to its original position and shape, demonstrating the periodic nature of the solution.\nStability: The CFL number was calculated as \\(C=0.5\\) , which satisfies the stability condition , \\(C\\leq 1\\). This ensures that the solution remains bounded and physically realistic.\nNumerical Dispersion: While not highly prominent in this example due to the smooth initial condition, some slight changes in the wave’s shape might be observed over longer simulation times. This is known as numerical dispersion, an artifact where different frequency components of the wave travel at slightly different speeds in the numerical grid.\n\nResult\nThe explicit finite difference method accurately captures the key dynamics of wave propagation and reflection, making it a powerful tool for analyzing such systems.",
    "crumbs": [
      "Partial Differential Equations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)</span>"
    ]
  },
  {
    "objectID": "02-pde-numerical.html#application-challenge-vibration-in-a-flexible-robot-link",
    "href": "02-pde-numerical.html#application-challenge-vibration-in-a-flexible-robot-link",
    "title": "3  Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)",
    "section": "3.6 Application Challenge: Vibration in a Flexible Robot Link",
    "text": "3.6 Application Challenge: Vibration in a Flexible Robot Link\nIn modern robotics, lightweight materials are used to create fast and efficient robots. However, these materials are often flexible. When a motor at the base of a robot link starts or stops suddenly, it can induce a longitudinal (compression/expansion) wave that travels down the link, causing vibrations at the end-effector (the robot’s tool or gripper). This vibration can severely impact the robot’s precision.\nWe can model this phenomenon using the 1D wave equation, where u(x,t) now represents the longitudinal displacement of the material from its resting position.\n\n\n\nSudden motor movement\n\n\n\n3.6.0.1 Your Task\nModel the vibration in a 2.0-meter long flexible robot link. * Physical Setup: * Base (x=0): Connected to a motor. We will model a sudden “jolt” by giving the base a brief, sharp displacement and then returning it to zero. * End-Effector (x=L): The end of the link is free to move. This is a Neumann boundary condition, which physically means the stress at the end is zero, or \\(\\frac{\\partial u}{\\partial x}(L, t) = 0\\). * Initial Conditions: The link is initially at rest. * Initial displacement \\(u(x,0) = 0\\). * Initial velocity \\(\\frac{\\partial u}{\\partial t}(x,0) = 0\\). * Wave Speed: The speed of sound (and thus stress waves) in this material is \\(c = 50\\) m/s.\n\n\n3.6.0.2 The Challenge\n\nImplement a New Boundary Condition: The motor’s jolt can be modeled by forcing the displacement at the base, u[n, 0], to be a short pulse. For example, a sine pulse for a very short duration at the beginning of the simulation.\nImplement the “Free End” (Neumann) Boundary: The condition \\(\\frac{\\partial u}{\\partial x}(L, t) = 0\\) can be approximated with a finite difference as \\(\\frac{u_{nx-1}^n - u_{nx-2}^n}{\\Delta x} = 0\\), which simplifies to \\(u_{nx-1}^n = u_{nx-2}^n\\). This means the last point always has the same displacement as the point next to it. You must enforce this at every time step.\nAnalyze the Result: Plot the displacement of the end-effector (u[:, -1]) over time to see how it vibrates in response to the motor’s jolt.\n\n\n\n3.6.0.3 Hints\n\nMotor Jolt: You can create the motor jolt inside the time-stepping loop. Use an if condition to apply the pulse only for a short time (e.g., when n*dt &lt; pulse_duration). A simple pulse could be u[n, 0] = A * np.sin(omega * n * dt).\nNeumann Boundary: After the main update loop for the interior points, add a line to enforce the free-end condition: u[n + 1, -1] = u[n + 1, -2]. The -1 index refers to the last element, and -2 refers to the second-to-last.\nStability: With a high wave speed (c=50), you will need a very small time step dt to satisfy the CFL condition (\\(C \\le 1\\)). Be prepared to use a large nt.\n\n\n\n3.6.1 Solution to the Robotics Application Challenge\nHere is the Python code that models the robot link vibration, incorporating the driving pulse at the base and the free-end boundary condition.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- 1. Parameters for the Robot Link ---\nL = 2.0             # Length of the robot link (m)\nc = 50.0            # Wave speed in the material (m/s)\nT = 0.15            # Total simulation time (s)\n\n# Discretization - fine grid needed for high wave speed\ndx = 0.04\n# dt must be chosen carefully for stability\ndt = dx / c * 0.9   # Choose dt based on dx and c to guarantee C=0.9\nC = c * dt / dx\n\nprint(f\"--- Robotics Challenge Parameters ---\")\nprint(f\"Wave Speed c = {c} m/s\")\nprint(f\"Courant Number C = {C:.2f}\")\nif C &gt; 1:\n    raise ValueError(\"CFL condition failed!\")\n\n# --- Grid setup ---\nx = np.arange(0, L + dx, dx)\nt_vec = np.arange(0, T + dt, dt)\nnx = len(x)\nnt = len(t_vec)\nu = np.zeros((nt, nx))\n\n# --- Motor Jolt Parameters ---\npulse_duration = 0.02  # s\npulse_amplitude = 0.001 # 1 mm jolt\npulse_frequency = 2 * np.pi / pulse_duration\n\n# --- 5. Time-stepping Loop with New Boundary Conditions ---\nfor n in range(1, nt - 1):\n    # Main update for interior points (from 2nd point to 2nd-to-last)\n    u[n + 1, 1:-1] = (2 * u[n, 1:-1] - u[n - 1, 1:-1] +\n                      C**2 * (u[n, 2:] - 2 * u[n, 1:-1] + u[n, :-2]))\n\n    # Boundary Condition 1: Motor Jolt at the Base (x=0)\n    current_time = n * dt\n    if current_time &lt; pulse_duration:\n        u[n + 1, 0] = pulse_amplitude * np.sin(pulse_frequency * current_time)\n    else:\n        u[n + 1, 0] = 0.0 # Motor holds firm at base after jolt\n\n    # Boundary Condition 2: Free End at x=L (Neumann)\n    # u_last = u_second_to_last\n    u[n + 1, -1] = u[n + 1, -2]\n\n# --- 6. Plot the End-Effector's Vibration ---\nend_effector_displacement = u[:, -1]\n\nplt.figure(figsize=(12, 6))\nplt.plot(t_vec, end_effector_displacement * 1000) # Convert to mm\nplt.title(\"Vibration of Robot End-Effector Over Time\")\nplt.xlabel(\"Time (s)\")\nplt.ylabel(\"Displacement (mm)\")\nplt.grid(True)\nplt.axhline(0, color='black', linewidth=0.5) # Zero line\nplt.show()\n\n\n--- Robotics Challenge Parameters ---\nWave Speed c = 50.0 m/s\nCourant Number C = 0.90\n\n\n\n\n\n\n\n\nFigure 3.6: Displacement of the robot link’s end-effector over time, showing vibrations induced by a motor jolt.",
    "crumbs": [
      "Partial Differential Equations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)</span>"
    ]
  },
  {
    "objectID": "03-laplace-basics.html",
    "href": "03-laplace-basics.html",
    "title": "4  Lab Session 3: Symbolic operations in Laplace Trandform",
    "section": "",
    "text": "4.1 Experiment 5: The Laplace Transform and Frequency Response\nThe Laplace Transform is a powerful mathematical tool used extensively in circuit analysis, control systems, and signal processing. It transforms a function from the time domain, \\(f(t)\\), into the frequency domain, \\(F(s)\\).\nWhile this is useful for solving differential equations, its true power in engineering comes from analyzing the frequency response. By setting the complex variable \\(s = j\\omega\\) (where \\(j\\) is the imaginary unit and \\(\\omega\\) is angular frequency), we can see how a system or signal behaves at different frequencies. This is analyzed through two key plots: the Magnitude Plot and the Phase Plot.",
    "crumbs": [
      "Laplace Transforms & System Analysis",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lab Session 3: Symbolic operations in Laplace Trandform</span>"
    ]
  },
  {
    "objectID": "03-laplace-basics.html#experiment-5-the-laplace-transform-and-frequency-response",
    "href": "03-laplace-basics.html#experiment-5-the-laplace-transform-and-frequency-response",
    "title": "4  Lab Session 3: Symbolic operations in Laplace Trandform",
    "section": "",
    "text": "4.1.1 Aim\nTo compute the Laplace transform of given functions and, most importantly, to visualize and interpret their frequency response through magnitude and phase plots.\n\n\n4.1.2 Objectives\n\nTo use Python’s SymPy library for symbolic Laplace transforms.\nTo understand how to obtain the frequency response function \\(F(j\\omega)\\) from the Laplace transform \\(F(s)\\).\nTo generate and interpret magnitude and phase plots.\nTo connect these plots to physical concepts like amplification, attenuation, and time delay (phase shift).\n\n\n\n\n4.1.3 Algorithm\n\nDefine Symbols: Use sp.symbols() to declare symbolic variables t (time), s (Laplace variable), and w (frequency, \\(\\omega\\)).\nDefine the Function: Specify the time-domain function \\(f(t)\\) as a symbolic expression.\nCompute Laplace Transform: Use sp.laplace_transform() to find the corresponding \\(F(s)\\).\nDerive Frequency Response: Substitute \\(s = j\\omega\\) into the symbolic expression for \\(F(s)\\) to get the frequency response function \\(F(j\\omega)\\).\nPrepare for Plotting: Convert the symbolic expressions for \\(f(t)\\) and \\(F(j\\omega)\\) into fast numerical functions using sp.lambdify().\nGenerate Data:\n\nCreate a numerical array of time points t_values.\nCreate a logarithmic array of frequency points w_values using np.logspace().\nCalculate the complex values of \\(F(j\\omega)\\) for the frequency range.\n\nCalculate Magnitude and Phase:\n\nMagnitude: np.abs(F_jw_values)\nPhase: np.angle(F_jw_values, deg=True) (in degrees for easier interpretation)\n\nPlot: Create three subplots: the time-domain signal, the magnitude plot (log-log scale), and the phase plot (log-x scale). This set of frequency plots is known as a Bode Plot.\n\n\n\n\n4.1.4 Case Study: An RC Low-Pass Filter’s Impulse Response\nProblem: The voltage response of a simple RC low-pass filter to a sharp input (an impulse) is an exponential decay function, \\(f(t) = e^{-at}\\), where \\(a = 1/RC\\). Let’s analyze this signal for \\(a=1\\).\nPhysical Interpretation: * Magnitude |F(jω)|: Tells us how much the filter will pass or block a sine wave of frequency \\(\\omega\\). * Phase arg(F(jω)): Tells us how much the filter will delay a sine wave of frequency \\(\\omega\\).\n\n\nCode\nimport sympy as sp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- 1. Define symbols ---\nt, s, w = sp.symbols('t s w', real=True, positive=True)\na = sp.Symbol('a', real=True, positive=True)\n\n# --- 2. Define the function ---\nf = sp.exp(-a*t)\n\n# --- 3. Compute Laplace Transform ---\nF_s = sp.laplace_transform(f, t, s, noconds=True)\n\n# --- Set parameter for our specific case ---\nf_case = f.subs(a, 1)\nF_s_case = F_s.subs(a, 1)\n\n# --- 4. Derive Frequency Response ---\nF_jw = F_s_case.subs(s, 1j * w)\n\n# --- Print the symbolic results ---\nprint(f\"Function: f(t) = {f_case}\")\nprint(f\"Laplace Transform: F(s) = {F_s_case}\")\nprint(f\"Frequency Response: F(jω) = {F_jw}\")\n\n# --- 5. Lambdify for numerical evaluation ---\nf_func = sp.lambdify(t, f_case, 'numpy')\nF_jw_func = sp.lambdify(w, F_jw, 'numpy')\n\n# --- 6. & 7. Generate Data and Calculate Mag/Phase ---\nt_values = np.linspace(0, 5, 400)\nf_values = f_func(t_values)\n\nw_values = np.logspace(-1, 2, 400) # From 0.1 to 100 rad/s\nF_jw_values = F_jw_func(w_values)\n\nmagnitude = np.abs(F_jw_values)\nphase = np.angle(F_jw_values, deg=True)\n\n# --- 8. Plotting ---\nplt.figure(figsize=(10, 8))\n\n# Plot f(t)\nplt.subplot(3, 1, 1)\nplt.plot(t_values, f_values, color='blue')\nplt.title('Time Domain: $f(t) = e^{-t}$ (Impulse Response of RC Filter)')\nplt.xlabel('Time (t)')\nplt.ylabel('Amplitude')\nplt.grid(True)\n\n# Plot Magnitude |F(jω)|\nplt.subplot(3, 1, 2)\nplt.loglog(w_values, magnitude, color='red')\nplt.title('Frequency Response: Magnitude Plot')\nplt.xlabel('Frequency (ω) [rad/s]')\nplt.ylabel('|F(jω)| (Gain)')\nplt.grid(True, which=\"both\", ls=\"-\")\n\n# Plot Phase arg(F(jω))\nplt.subplot(3, 1, 3)\nplt.semilogx(w_values, phase, color='purple')\nplt.title('Frequency Response: Phase Plot')\nplt.xlabel('Frequency (ω) [rad/s]')\nplt.ylabel('Phase (degrees)')\nplt.grid(True, which=\"both\", ls=\"-\")\n\nplt.tight_layout()\nplt.show()\n\n\nFunction: f(t) = exp(-t)\nLaplace Transform: F(s) = 1/(s + 1)\nFrequency Response: F(jω) = 1/(1.0*I*w + 1)\n\n\n\n\n\n\n\n\nFigure 4.1: Time-domain plot of an exponential decay and its corresponding Bode Plot (Magnitude and Phase).\n\n\n\n\n\n\n\n4.1.5 Results and Discussion\n\nTime Domain: The function \\(e^{-t}\\) shows a sharp start at 1, followed by a slow decay.\nMagnitude Plot: This plot clearly shows the behavior of a low-pass filter. At low frequencies (e.g., \\(\\omega&lt;1\\)), the magnitude (gain) is close to 1, meaning these signals are passed through without attenuation. As frequency increases, the magnitude rolls off, indicating that high-frequency signals are blocked. The “corner frequency” where the roll-off begins is at \\(\\omega=1/a=1\\) rad/s.\nPhase Plot: At very low frequencies, the phase shift is near 0 degrees. As the frequency approaches the corner frequency, the phase lag increases, reaching -45 degrees at \\(\\omega=1\\) rad/s. At very high frequencies, the phase shift approaches -90 degrees, meaning a high-frequency sine wave passing through this filter will be delayed by a quarter of its cycle. This delay is a fundamental property of physical systems like filters.\n\n\n\n4.1.6 Application Challenge 1: A Damped Oscillator\nYour Task: Analyze a signal representing a damped sine wave, which is characteristic of many mechanical and electrical systems that oscillate but lose energy over time (e.g., a mass on a spring with friction, or an RLC circuit). The function is given by: \\(f(t)=e^{-at}\\sin(\\omega t)\\). Use the following parameters: \\(a = 0.5\\) (Damping factor), \\(\\omega_0 =5\\) rad/s (Natural oscillation frequency). Follow the full algorithm to produce the time-domain plot and the full Bode plot (magnitude and phase).\n\nSolution to the Application Challenge\n\n\n\nCode\n# --- Define symbols and parameters ---\nt, s, w = sp.symbols('t s w', real=True, positive=True)\na = sp.Symbol('a', real=True, positive=True)\nw0 = sp.Symbol('w0', real=True, positive=True)\n\n# --- Define the function ---\nf_damped = sp.exp(-a*t) * sp.sin(w0*t)\n\n# --- Compute its Laplace Transform using the frequency shift theorem ---\n# The transform of e^(-at)f(t) is F(s+a)\nF_s_damped = sp.laplace_transform(sp.sin(w0*t), t, s)[0].subs(s, s + a)\n\n# --- Set parameters for our specific case ---\nparams = {a: 0.5, w0: 5}\nf_case_damped = f_damped.subs(params)\nF_s_case_damped = F_s_damped.subs(params)\n\n# --- Derive Frequency Response ---\nF_jw_damped = F_s_case_damped.subs(s, 1j * w)\n\n# --- Print the symbolic results ---\nprint(f\"Function: f(t) = {f_case_damped}\")\nprint(f\"Laplace Transform: F(s) = {sp.simplify(F_s_case_damped)}\")\nprint(f\"Frequency Response: F(jω) = {F_jw_damped}\")\n\n# --- Lambdify for numerical evaluation ---\nf_damped_func = sp.lambdify(t, f_case_damped, 'numpy')\nF_jw_damped_func = sp.lambdify(w, F_jw_damped, 'numpy')\n\n# --- Generate Data ---\nt_values = np.linspace(0, 8, 500)\nf_values = f_damped_func(t_values)\n\nw_values = np.logspace(-1, 2, 500)\nF_jw_values = F_jw_damped_func(w_values)\nmagnitude = np.abs(F_jw_values)\nphase = np.angle(F_jw_values, deg=True)\n\n# --- Plotting (with raw strings for all labels) ---\nplt.figure(figsize=(10, 8))\n\nplt.subplot(3, 1, 1)\nplt.plot(t_values, f_values, color='blue')\nplt.title(r'Time Domain: Damped Sine Wave $f(t) = e^{-0.5t} \\sin(5t)$')\nplt.xlabel(r'Time (t)')\nplt.ylabel(r'Amplitude')\nplt.grid(True)\n\nplt.subplot(3, 1, 2)\nplt.loglog(w_values, magnitude, color='red')\nplt.title(r'Frequency Response: Magnitude Plot')\nplt.axvline(x=5, color='gray', linestyle='--', label=r'Natural Freq. ($\\omega_{0}$=5)')\nplt.xlabel(r'Frequency ($\\omega$) [rad/s]')\nplt.ylabel(r'|F(j$\\omega$)| (Gain)')\nplt.legend()\nplt.grid(True, which=\"both\", ls=\"-\")\n\nplt.subplot(3, 1, 3)\nplt.semilogx(w_values, phase, color='purple')\nplt.title(r'Frequency Response: Phase Plot')\nplt.axvline(x=5, color='gray', linestyle='--', label=r'Natural Freq. ($\\omega_{0}$=5)')\nplt.xlabel(r'Frequency ($\\omega$) [rad/s]')\nplt.ylabel(r'Phase (degrees)')\nplt.legend()\nplt.grid(True, which=\"both\", ls=\"-\")\n\nplt.tight_layout()\nplt.show()\n\n\nFunction: f(t) = exp(-0.5*t)*sin(5*t)\nLaplace Transform: F(s) = 5/((s + 0.5)**2 + 25)\nFrequency Response: F(jω) = 5/((1.0*I*w + 0.5)**2 + 25)\n\n\n\n\n\n\n\n\nFigure 4.2: Analysis of a damped sine wave, showing a resonant peak in its frequency response.\n\n\n\n\n\n\nDiscussion of Challenge Solution\n\n\nTime Domain: The signal is a sine wave whose amplitude decays exponentially over time, which is exactly what we expect from the function.\nMagnitude Plot: This plot shows a clear resonant peak. The gain is highest for input frequencies very close to the system’s natural oscillation frequency, \\(\\omega_0=5\\) rad/s. This means if you “excite” this system with a frequency of 5 rad/s, it will respond with the largest amplitude. This phenomenon is critical in understanding both mechanical resonance (e.g., why soldiers break step on bridges) and electrical resonance (e.g., tuning a radio).\nPhase Plot: The phase experiences a very rapid shift of 180 degrees around the resonant frequency. It starts at 0 degrees (for very low frequencies), drops sharply to -180 degrees through the resonance point, indicating a complete inversion of the signal’s phase. This sharp phase change is a key indicator of resonance in a system.\n\n\nResult\n\nBy focusing on magnitude and phase, this experiment provides us with a much deeper and more practical understanding of the Laplace transform’s role in engineering.\n\n\n\n4.1.7 Application Challenge 2: Combined Decay and Ramp Signal\nYour Task: Consider a signal that represents the voltage in a circuit with both a discharging capacitor component and a linearly increasing input voltage. The combined signal is given by: \\[\nf(t) = A e^{-\\alpha t} + B t\n\\]\nCompute and visualize the Laplace transform and frequency response for this function using the following parameters:\n\nA = 5 (Initial amplitude of the exponential decay)\n\\(\\alpha = 2\\) (Decay rate)\nB = 3 (Slope of the ramp function)\n\nFollow the full algorithm to produce the time-domain plot and the full Bode plot (magnitude and phase).\n\n\n\n4.1.8 Solution to the Application Challenge 2\nHere is the complete Python code to solve the application challenge. We’ll analyze how the combination of a decaying signal and a constantly growing ramp signal appears in the frequency domain.\n\n\nCode\n# --- Define symbols and parameters ---\nimport sympy as sp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nt, s, w = sp.symbols('t s w', real=True, positive=True)\nA, alpha, B = sp.symbols('A alpha B', real=True, positive=True)\n\n# --- Define the function ---\nf_combined = A * sp.exp(-alpha * t) + B * t\n\n# --- Compute its Laplace Transform ---\n# SymPy can handle the sum directly due to the linearity of the transform\nF_s_combined = sp.laplace_transform(f_combined, t, s)[0]\n\n# --- Set parameters for our specific case ---\nparams = {A: 5, alpha: 2, B: 3}\nf_case_combined = f_combined.subs(params)\nF_s_case_combined = F_s_combined.subs(params)\n\n# --- Derive Frequency Response ---\nF_jw_combined = F_s_case_combined.subs(s, 1j * w)\n\n# --- Print the symbolic results ---\nprint(f\"Function: f(t) = {f_case_combined}\")\n# We can use simplify to combine the terms into a single fraction\nprint(f\"Laplace Transform: F(s) = {sp.simplify(F_s_case_combined)}\")\nprint(f\"Frequency Response: F(jω) = {F_jw_combined}\")\n\n# --- Lambdify for numerical evaluation ---\nf_combined_func = sp.lambdify(t, f_case_combined, 'numpy')\nF_jw_combined_func = sp.lambdify(w, F_jw_combined, 'numpy')\n\n# --- Generate Data ---\nt_values = np.linspace(0, 3, 400)\nf_values = f_combined_func(t_values)\n\n# Frequency range for plotting (logarithmic scale)\nw_values = np.logspace(-1, 2, 400) # From 0.1 to 100 rad/s\nF_jw_values = F_jw_combined_func(w_values)\n\n# Calculate Magnitude and Phase\nmagnitude = np.abs(F_jw_values)\nphase = np.angle(F_jw_values, deg=True)\n\n# --- Plotting ---\nplt.figure(figsize=(10, 8))\n\n# Plot f(t)\nplt.subplot(3, 1, 1)\nplt.plot(t_values, f_values, color='blue')\nplt.title(r'Time Domain: $f(t) = 5e^{-2t} + 3t$')\nplt.xlabel(r'Time (t)')\nplt.ylabel(r'Amplitude')\nplt.grid(True)\n\n# Plot Magnitude |F(jω)|\nplt.subplot(3, 1, 2)\nplt.loglog(w_values, magnitude, color='red')\nplt.title(r'Frequency Response: Magnitude Plot')\nplt.xlabel(r'Frequency ($\\omega$) [rad/s]')\nplt.ylabel(r'|F(j$\\omega$)| (Gain)')\nplt.grid(True, which=\"both\", ls=\"-\")\n\n# Plot Phase arg(F(jω))\nplt.subplot(3, 1, 3)\nplt.semilogx(w_values, phase, color='purple')\nplt.title(r'Frequency Response: Phase Plot')\nplt.xlabel(r'Frequency ($\\omega$) [rad/s]')\nplt.ylabel(r'Phase (degrees)')\nplt.grid(True, which=\"both\", ls=\"-\")\n\nplt.tight_layout()\nplt.show()\n\n\nFunction: f(t) = 3*t + 5*exp(-2*t)\nLaplace Transform: F(s) = 5/(s + 2) + 3/s**2\nFrequency Response: F(jω) = 5/(1.0*I*w + 2) - 3.0/w**2\n\n\n\n\n\n\n\n\nFigure 4.3: Analysis of a combined exponential decay and ramp signal.\n\n\n\n\n\n\n4.1.8.1 Results and Discussion of the Challenge\nThe symbolic computation confirms that the Laplace transform of \\(f(t)=5e^{-2t}+3t\\) is, \\(F(s)=\\frac{5}{s^2+2}+\\frac{2}{s^2}\\). The frequency analysis reveals how these two components interact.\n\nTime-Domain Plot: The plot shows the function starting at an amplitude of 5 (from the \\(Ae^{-at}\\) term). For a short time, the function’s value decreases as the exponential decay is stronger than the ramp’s growth. However, as t increases, the decay term vanishes and the ramp term (\\(3t\\)) dominates, causing the signal to increase linearly.\nMagnitude Plot: The magnitude plot is dominated by the ramp function at low frequencies. The \\(\\frac{1}{s^2}\\) term in the transform results in a very high magnitude as \\(\\omega \\to 0\\). This is because a ramp is a signal with infinite energy concentrated at the lowest frequencies (it never stops growing). The plot shows a steep roll-off, characteristic of this term. The influence of the exponential term \\(\\frac{5}{s+2}\\) is seen as a “shoulder” in the plot around \\(\\omega=2\\) rad/s, but it’s a minor feature compared to the ramp’s overwhelming low-frequency content.\nPhase Plot: The phase plot is particularly interesting. At very low frequencies, the phase approaches -180 degrees. This is a direct consequence of the \\(\\frac{1}{s^2}\\) term from the ramp. In the frequency domain, \\(s^2\\to (j\\omega)^2\\to -\\omega^2\\). A negative real number has a phase of -180 degrees (or +180). As frequency increases, the phase begins to rise, influenced by the other term in the transform, whose phase is between 0 and -90 degrees. This shows the complex interplay between the phase characteristics of the two combined signals.\n\nThis analysis demonstrates how the frequency response can deconstruct a complex time-domain signal, revealing the distinct spectral “fingerprints” of its constituent parts.",
    "crumbs": [
      "Laplace Transforms & System Analysis",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lab Session 3: Symbolic operations in Laplace Trandform</span>"
    ]
  },
  {
    "objectID": "03-laplace-basics.html#experiment-6-the-inverse-laplace-transform",
    "href": "03-laplace-basics.html#experiment-6-the-inverse-laplace-transform",
    "title": "4  Lab Session 3: Symbolic operations in Laplace Trandform",
    "section": "4.2 Experiment 6: The Inverse Laplace Transform",
    "text": "4.2 Experiment 6: The Inverse Laplace Transform\nAfter analyzing a system or signal in the frequency domain, we often need to return to the time domain to understand the actual physical behavior—how voltage changes, how a robot arm moves, etc. The Inverse Laplace Transform, denoted \\(\\mathcal{L}^{-1}\\{F(s)\\}\\), accomplishes this, converting a function \\(F(s)\\) back into its time-domain equivalent, \\(f(t)\\).\n\n4.2.1 Aim\nTo compute the Inverse Laplace transform of given s-domain functions and to visualize the connection between the frequency-domain characteristics and the resulting time-domain signal.\n\n\n4.2.2 Objectives\n\nTo use SymPy to calculate the inverse Laplace transform of a given function \\(F(s)\\).\nTo analyze the frequency response (magnitude and phase) of the given \\(F(s)\\).\nTo plot the resulting time-domain function \\(f(t)\\).\nTo visually connect features in the frequency domain (like resonant peaks) to behaviors in the time domain (like oscillations).\n\n\n\n\n4.2.3 Algorithm\n\nImport Libraries: Import sympy, numpy, and matplotlib.pyplot.\nDefine Symbols: Declare symbolic variables s, t, and w.\nDefine Laplace-Domain Function: Specify the s-domain function \\(F(s)\\) as a symbolic expression.\nAnalyze Frequency Response of F(s):\n\nSubstitute \\(s = j\\omega\\) to get the frequency response function \\(F(j\\omega)\\).\nLambdify \\(F(j\\omega)\\) to prepare for numerical plotting.\nGenerate a frequency array w_values and calculate the magnitude and phase of \\(F(j\\omega)\\).\n\nCompute the Inverse Laplace Transform:\n\nUse sp.inverse_laplace_transform(F, s, t)[0] to find the time-domain function \\(f(t)\\).\nLambdify the resulting symbolic expression \\(f(t)\\).\n\nPlot and Visualize: Create a set of plots to show the full picture:\n\nThe Magnitude plot of \\(F(j\\omega)\\).\nThe Phase plot of \\(F(j\\omega)\\).\nThe resulting time-domain plot of \\(f(t)\\).\n\n\n\n\n\n4.2.4 Case Study: An Ideal Resonator\nProblem: You are given the s-domain function \\(F(s) = \\frac{1}{s^2 + 1}\\). This is the transfer function of an ideal, undamped second-order system (like a frictionless mass-spring or a lossless LC circuit). Analyze its frequency response and find its impulse response in the time domain by computing the inverse Laplace transform.\nTheoretical Result: This is the classic transform pair for \\(\\sin(t)\\).\n\n\nCode\nimport sympy as sp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- 1. & 2. Define symbols ---\ns, t, w = sp.symbols('s t w', real=True, positive=True)\n\n# --- 3. Define Laplace-domain function ---\nF_s = 1 / (s**2 + 1)\n\n# --- 4. Analyze Frequency Response of F(s) ---\nF_jw = F_s.subs(s, 1j * w)\nF_jw_func = sp.lambdify(w, F_jw, 'numpy')\n\nw_values = np.logspace(-1, 2, 500)\nF_jw_values = F_jw_func(w_values)\nmagnitude = np.abs(F_jw_values)\nphase = np.angle(F_jw_values, deg=True)\n\n# --- 5. Compute Inverse Laplace Transform ---\nf_t = sp.inverse_laplace_transform(F_s, s, t, noconds=True)\nf_t_func = sp.lambdify(t, f_t, 'numpy')\n\nprint(f\"The given F(s) is: {F_s}\")\nprint(f\"The computed Inverse Laplace Transform f(t) is: {f_t}\")\n\n# --- 6. Plotting ---\nt_values = np.linspace(0, 10, 500)\n\nplt.figure(figsize=(10, 8))\n\n# Plot Magnitude\nplt.subplot(3, 1, 1)\nplt.loglog(w_values, magnitude, color='red')\nplt.title(r'Frequency Response of $F(s)$: Magnitude')\nplt.ylabel(r'|F(j$\\omega$)| (Gain)')\nplt.axvline(x=1, color='gray', linestyle='--', label=r'Resonant Freq. ($\\omega$=1)')\nplt.grid(True, which=\"both\", ls=\"-\")\nplt.legend()\n\n# Plot Phase\nplt.subplot(3, 1, 2)\nplt.semilogx(w_values, phase, color='purple')\nplt.title(r'Frequency Response of $F(s)$: Phase')\nplt.ylabel(r'Phase (degrees)')\nplt.axvline(x=1, color='gray', linestyle='--', label=r'Resonant Freq. ($\\omega$=1)')\nplt.grid(True, which=\"both\", ls=\"-\")\nplt.legend()\n\n# Plot Time-domain response f(t)\nplt.subplot(3, 1, 3)\nplt.plot(t_values, f_t_func(t_values), color='blue')\nplt.title(r'Resulting Time-Domain Function: $f(t) = \\mathcal{L}^{-1}\\{F(s)\\}$')\nplt.xlabel(r'Time (t)')\nplt.ylabel(r'$f(t)$')\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n\n\nThe given F(s) is: 1/(s**2 + 1)\nThe computed Inverse Laplace Transform f(t) is: sin(t)\n\n\n\n\n\n\n\n\nFigure 4.4: Bode Plot of F(s) = 1/(s^2+1) and its corresponding time-domain response, f(t)=sin(t).\n\n\n\n\n\n\n4.2.4.1 Results and Discussion\nThis example provides a perfect illustration of the connection between the frequency and time domains.\n\nFrequency Domain Analysis: The magnitude plot shows an infinitely sharp resonant peak at \\(\\omega=1\\) rad/s. This tells us the system is extremely sensitive to inputs at this specific frequency and will have a massive response. The phase plot shows an instantaneous 180-degree flip at \\(\\omega=1\\), another hallmark of ideal resonance.\nTime Domain Result: The inverse Laplace transform correctly yields \\(f(t)=sin(t)\\). The plot of this function is an undamped sine wave that oscillates forever. This is the time-domain manifestation of the infinite resonant peak seen in the frequency domain. An undamped system, when “hit” by an impulse, will oscillate at its natural frequency indefinitely.",
    "crumbs": [
      "Laplace Transforms & System Analysis",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lab Session 3: Symbolic operations in Laplace Trandform</span>"
    ]
  },
  {
    "objectID": "03-laplace-basics.html#application-challenge-step-response-of-an-rlc-circuit",
    "href": "03-laplace-basics.html#application-challenge-step-response-of-an-rlc-circuit",
    "title": "4  Lab Session 3: Symbolic operations in Laplace Trandform",
    "section": "4.3 Application Challenge: Step Response of an RLC Circuit",
    "text": "4.3 Application Challenge: Step Response of an RLC Circuit\nProblem: Consider a series RLC circuit which is initially at rest (zero initial conditions). A step voltage of 5 volts is applied at \\(t=0\\). Determine the step response of the circuit, i.e., the current \\(i(t)\\) as a function of time, using the inverse Laplace transform method. Use the following component values:\n\nResistance (R): 10 Ω\nInductance (L): 0.1 H\nCapacitance (C): 0.001 F (1 mF)\n\n\nCircuit Analysis\n\nFor a series RLC circuit, Kirchhoff’s Voltage Law (KVL) gives:\n\\[\nL \\frac{di(t)}{dt} + R i(t) + \\frac{1}{C} \\int_0^t i(\\tau) \\, d\\tau = v_s(t)\n\\]\nTaking the Laplace transform of the entire equation (with zero initial conditions):\n\\[\nsLI(s) + RI(s) + \\frac{1}{sC}I(s) = V(s)\n\\]\nThe input is a step voltage of 5V, so \\(v_s(t) = 5u(t)\\), and its transform is \\(V(s) = \\frac{5}{s}\\). Substituting for \\(V(s)\\) and solving for the current \\(I(s)\\):\n\\[\nI(s) \\left( sL + R + \\frac{1}{sC} \\right) = \\frac{5}{s} \\implies I(s) = \\frac{\\frac{5}{s}}{sL + R + \\frac{1}{sC}}\n\\]\nSimplifying this expression gives us the function we need to find the inverse transform of:\n\\[\nI(s) = \\frac{5/L}{s^2 + \\frac{R}{L}s + \\frac{1}{LC}}\n\\]\n\n\nCode\nimport sympy as sp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- Define symbols and parameters ---\ns, t = sp.symbols('s t', real=True, positive=True)\nR_val, L_val, C_val, V_val = 10, 0.1, 0.001, 5\n\n# --- Define the s-domain function I(s) ---\n# Derived from the circuit analysis above\nI_s = (V_val / L_val) / (s**2 + (R_val / L_val) * s + 1 / (L_val * C_val))\nprint(f\"The s-domain expression for the current is I(s) =\")\nsp.pprint(I_s)\n\n# --- Compute the Inverse Laplace Transform to find i(t) ---\n# &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; FIX IS HERE: Add noconds=True &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\ni_t = sp.inverse_laplace_transform(I_s, s, t, noconds=True)\n# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nprint(\"\\nThe time-domain expression for the current is i(t) =\")\nsp.pprint(i_t)\n\n# --- Lambdify for plotting ---\ni_t_func = sp.lambdify(t, i_t, 'numpy')\n\n# --- Generate time values and plot ---\nt_values = np.linspace(0, 0.1, 500) # The action happens quickly\ni_values = i_t_func(t_values)\n\nplt.figure(figsize=(10, 5))\nplt.plot(t_values, i_values, color='blue')\nplt.title(r'RLC Circuit Step Response: Current $i(t)$')\nplt.xlabel(r'Time (t) [seconds]')\nplt.ylabel(r'Current (i) [Amps]')\nplt.grid(True)\nplt.show()\n\n\nThe s-domain expression for the current is I(s) =\n         50.0         \n──────────────────────\n 2                    \ns  + 100.0⋅s + 10000.0\n\nThe time-domain expression for the current is i(t) =\n                   -50.0⋅t                        \n0.577350269189626⋅ℯ       ⋅sin(86.6025403784439⋅t)\n\n\n\n\n\n\n\n\nFigure 4.5: The current i(t) in an RLC circuit after a 5V step input is applied.\n\n\n\n\n\n\n4.3.0.1 Discussion of RLC Circuit Result\nThe inverse Laplace transform provides the exact analytical solution for the current \\(i(t)\\) in the circuit.\n\nUnderdamped Response: The plot shows a classic underdamped response. When the voltage is applied, the current surges to a peak, overshoots the final steady-state value, and then oscillates with decreasing amplitude until it settles.\nSteady-State Behavior: As \\(t\\to \\infty\\), the current \\(i(t)\\to 0\\). This is physically correct. In a DC circuit, after the initial transient period, the inductor acts like a short circuit (a wire) and the capacitor acts as an open circuit. Since the capacitor blocks the DC current in the steady state, the final current must be zero.\nConnection to System Poles: The oscillatory behavior is due to the complex conjugate poles of the denominator of \\(I(s)\\). If the poles were real and distinct, the response would be overdamped (no oscillation). If the poles were real and repeated, it would be critically damped. This problem beautifully demonstrates how the mathematical properties of \\(F(s)\\) directly dictate the physical nature of \\(f(t)\\).",
    "crumbs": [
      "Laplace Transforms & System Analysis",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lab Session 3: Symbolic operations in Laplace Trandform</span>"
    ]
  },
  {
    "objectID": "04-laplace-apps.html",
    "href": "04-laplace-apps.html",
    "title": "5  Lab Session 4: Applications of Laplace Transform",
    "section": "",
    "text": "5.1 Experiment 7: Solving Differential Equations with Laplace Transforms\nThe true power of the Laplace Transform in engineering is its ability to convert complex differential equations (in the time domain) into simple algebraic equations (in the \\(s\\)-domain). This experiment demonstrates this powerful technique.",
    "crumbs": [
      "Laplace Transforms & System Analysis",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Lab Session 4: Applications of Laplace Transform</span>"
    ]
  },
  {
    "objectID": "04-laplace-apps.html#experiment-7-solving-differential-equations-with-laplace-transforms",
    "href": "04-laplace-apps.html#experiment-7-solving-differential-equations-with-laplace-transforms",
    "title": "5  Lab Session 4: Applications of Laplace Transform",
    "section": "",
    "text": "5.1.1 Aim\nTo solve an ordinary differential equation (ODE) using the Laplace Transform method and to visualize the resulting solution.\n\n\n5.1.2 Objectives\n\nTo understand the process of transforming an entire ODE into the s-domain.\nTo solve for the system’s response algebraically in the s-domain.\nTo use the Inverse Laplace Transform to bring the solution back into the time domain.\nTo obtain and visualize both the symbolic and numerical solutions.\n\n\n\n\n5.1.3 Algorithm: The Laplace Transform Method for ODEs\nThe process follows a clear, three-step “detour” through the s-domain:\n\nTransform: Take the Laplace Transform of every term in the differential equation. Use the transform properties for derivatives:\n\n\\(\\mathcal{L}\\{y'(t)\\} = sY(s) - y(0)\\)\n\\(\\mathcal{L}\\{y''(t)\\} = s^2Y(s) - sy(0) - y'(0)\\) This step converts the ODE into an algebraic equation in terms of \\(Y(s)\\), automatically incorporating the initial conditions.\n\nSolve Algebraically: Rearrange the resulting algebraic equation to solve for \\(Y(s)\\). This \\(Y(s)\\) is the Laplace Transform of the solution to the ODE.\nInverse Transform: Apply the Inverse Laplace Transform to \\(Y(s)\\) to find the final solution, \\(y(t) = \\mathcal{L}^{-1}\\{Y(s)\\}\\).\n\nThis method elegantly bypasses the need for finding homogeneous and particular solutions, as is done in traditional time-domain methods.\n\n\n\n5.1.4 Case Study: First-Order RC Circuit Model\nProblem: Using the Laplace Transform, find the solution of the differential equation \\(y' + y = 1\\) with the initial condition \\(y(0)=0\\). This equation models the voltage across a capacitor in a simple RC circuit (with R=1, C=1) connected to a 1V DC source.\nStep-by-Step Solution:\n\nTransform the ODE:\n\n\\(\\mathcal{L}\\{y'(t)\\} + \\mathcal{L}\\{y(t)\\} = \\mathcal{L}\\{1\\}\\)\n\\(\\left[ sY(s) - y(0) \\right] + Y(s) = \\frac{1}{s}\\)\n\nIncorporate Initial Conditions and Solve for Y(s):\n\nSince \\(y(0)=0\\), the equation becomes: \\(sY(s) + Y(s) = \\frac{1}{s}\\)\nFactor out \\(Y(s)\\): \\(Y(s)(s + 1) = \\frac{1}{s}\\)\nSolve for \\(Y(s)\\): \\(Y(s) = \\frac{1}{s(s+1)}\\)\n\nInverse Transform:\n\nFind \\(y(t) = \\mathcal{L}^{-1}\\left\\{\\frac{1}{s(s+1)}\\right\\}\\). This can be done using partial fraction expansion, yielding \\(y(t) = 1 - e^{-t}\\).\n\n\nLet’s verify this process using Python.\n\n\nCode\nimport sympy as sp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- 1. Define Symbols and the ODE ---\nt = sp.Symbol('t', positive=True)\ns = sp.Symbol('s')\ny = sp.Function('y')\n\n# Define the differential equation: y'(t) + y(t) - 1 = 0\node = y(t).diff(t) + y(t) - 1\n\n# --- 2. Solve directly using SymPy's dsolve with Laplace method ---\n# This automates the transform, solve, and inverse transform steps.\n# We provide the initial condition y(0)=0 via the 'ics' argument.\nsolution = sp.dsolve(ode, ics={y(0): 0})\n\n# Display the symbolic solution\nprint(\"The symbolic solution is:\")\ndisplay(solution)\ny_t = solution.rhs # Extract the right-hand side for plotting\n\n# --- 3. Visualize the Solution ---\n# Convert the symbolic solution into a numerical function for plotting\ny_func = sp.lambdify(t, y_t, modules=['numpy'])\n\n# Generate time values for the plot\nt_vals = np.linspace(0, 5, 400)\ny_vals = y_func(t_vals)\n\n# Plot the result\nplt.figure(figsize=(8, 5))\nplt.plot(t_vals, y_vals, label=f\"y(t) = {y_t}\", color='blue')\nplt.title(\"Solution of y' + y = 1 using Laplace Transform\")\nplt.xlabel(\"Time (t)\")\nplt.ylabel(\"y(t)\")\nplt.grid(True)\nplt.legend()\nplt.show()\n\n\nThe symbolic solution is:\n\n\n\n\n\n\n\n\\(\\displaystyle y{\\left(t \\right)} = 1 - e^{- t}\\)\n\n\n(a) Solution of y’ + y = 1 with y(0)=0, representing a charging capacitor.\n\n\n\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\nFigure 5.1\n\n\n\n\n\n\n5.1.5 Result and Discussion\nThe solution obtained is \\(y(t)=1−e^{−t}\\). The visualization confirms the behavior described by this function: The solution curve starts at the point \\((0,0)\\), satisfying the initial condition \\(y(0)=0\\). As time t increases, the exponential term \\(e^{−t}\\) decays towards zero. Consequently, the solution \\(y(t)\\) asymptotically approaches the value of 1, which is the steady-state response of the system. This behavior is characteristic of a first-order system (like an RC circuit) responding to a step input.\n\n\n5.1.6 Application Problem: Mass-Spring-Damper System\nIn robotics and mechanical engineering, a mass-spring-damper system is a fundamental model for oscillatory behavior, such as a robot arm with flexibility or a vehicle’s suspension. Governing Equation: The motion of the mass \\(y(t)\\) is described by the second-order linear ODE: \\[\nmy''(t)+cy'(t)+ky(t)=F(t)\n\\]\nYour Task:\nSolve for the motion of a system with the following parameters: - Mass (m): 1 kg - Damping coefficient (c): 2 Ns/m (This represents friction/drag) - Spring constant (k): 5 N/m - External Force (F(t)): 0 (The system is disturbed and then left alone) - Initial Conditions: The system is pulled from its equilibrium position and released from rest.\nInitial position: \\(y(0)=1\\) meter Initial velocity: \\(y'(0)=0\\) m/s\nUse the Laplace Transform method in SymPy to find and visualize the displacement \\(y(t)\\).\n\nSolution to the Application Problem: Mass-Spring-Damper System\n\nWe will now solve the second-order ODE for the mass-spring-damper system using the same sympy.dsolve method, which internally uses the Laplace transform technique.\nProblem Recap:\n\nEquation: \\(1 \\cdot y''(t) + 2 \\cdot y'(t) + 5 \\cdot y(t) = 0\\)\nInitial Conditions: \\(y(0) = 1\\), \\(y'(0) = 0\\)\n\nManual Laplace Transform Steps (for understanding):\n\nTransform the ODE:\n\n\\(\\mathcal{L}\\{y''\\} + 2\\mathcal{L}\\{y'\\} + 5\\mathcal{L}\\{y\\} = \\mathcal{L}\\{0\\}\\)\n\\(\\left[s^2Y(s) - sy(0) - y'(0)\\right] + 2\\left[sY(s) - y(0)\\right] + 5Y(s) = 0\\)\n\nIncorporate Initial Conditions:\n\n\\(\\left[s^2Y(s) - s(1) - 0\\right] + 2\\left[sY(s) - 1\\right] + 5Y(s) = 0\\)\n\\(s^2Y(s) - s + 2sY(s) - 2 + 5Y(s) = 0\\)\n\nSolve for Y(s):\n\n\\(Y(s)(s^2 + 2s + 5) = s + 2\\)\n\\(Y(s) = \\frac{s+2}{s^2 + 2s + 5}\\)\n\nInverse Transform: Find \\(y(t) = \\mathcal{L}^{-1}\\left\\{ \\frac{s+2}{s^2 + 2s + 5} \\right\\}\\). This requires completing the square in the denominator and using the transform pairs for damped sinusoids.\n\nLet’s use Python to perform these steps automatically and visualize the result.\n\n5.1.6.1 Python Implementation\n\n\nCode\nimport sympy as sp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- 1. Define Symbols, Function, and Parameters ---\nt = sp.Symbol('t', positive=True)\ny = sp.Function('y')\n\n# System parameters\nm = 1.0\nc_damp = 2.0  # Renamed to avoid conflict with sympy's 'c' symbol\nk = 5.0\n\n# --- 2. Define and Solve the ODE ---\n# Define the differential equation: my'' + cy' + ky = 0\node = m * y(t).diff(t, 2) + c_damp * y(t).diff(t) + k * y(t)\n\n# Define the initial conditions in a dictionary\n# The derivative at t=0 is specified using .subs()\nics = {y(0): 1, y(t).diff(t).subs(t, 0): 0}\n\n# Solve the ODE using dsolve. SymPy automatically handles this structure.\nsolution = sp.dsolve(ode, ics=ics)\n\n# Display the symbolic solution\nprint(\"The symbolic solution for the system's motion is:\")\ndisplay(solution)\ny_t = solution.rhs\n\n# --- 3. Visualize the Solution ---\n# Convert the symbolic solution into a numerical function\ny_func = sp.lambdify(t, y_t, modules=['numpy'])\n\n# Generate time values for the plot\nt_vals = np.linspace(0, 5, 500)\ny_vals = y_func(t_vals)\n\n# Plot the result\nplt.figure(figsize=(10, 6))\nplt.plot(t_vals, y_vals, label=f\"y(t)\", color='purple')\n# Plot an exponential decay envelope to highlight the damping\nenvelope = np.exp(-t_vals) # From the e^(-t) term in the solution\nplt.plot(t_vals, envelope, 'k--', label='Damping Envelope e^(-t)', alpha=0.7)\nplt.plot(t_vals, -envelope, 'k--', alpha=0.7)\n\nplt.title(\"Motion of an Underdamped Mass-Spring-Damper System\")\nplt.xlabel(\"Time (t) [s]\")\nplt.ylabel(\"Displacement y(t) [m]\")\nplt.grid(True)\nplt.legend()\nplt.show()\n\n\nThe symbolic solution for the system's motion is:\n\n\n\n\n\n\n\n\\(\\displaystyle y{\\left(t \\right)} = \\left(0.5 \\sin{\\left(2.0 t \\right)} + 1.0 \\cos{\\left(2.0 t \\right)}\\right) e^{- 1.0 t}\\)\n\n\n(a) Underdamped oscillatory motion of a mass-spring-damper system.\n\n\n\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\nFigure 5.2\n\n\n\n\n\n\n5.1.6.2 Results and Discussion\nSymbolic Solution: The solution obtained is \\(y(t)=(\\sin(2t)+\\cos(2t))e^{−t}\\). This mathematical form is characteristic of an underdamped second-order system. It consists of two parts:\n\nOscillatory Part: \\(y(t)=(\\sin(2t)+\\cos(2t))e^{-t}\\) represents the natural oscillation of the mass on the spring. The frequency of this oscillation is \\(\\omega=2\\) rad/s.\nDecay Part: \\(e^{-t}\\) is an exponential decay envelope that multiplies the oscillation. This term represents the effect of the damper (friction), which removes energy from the system over time.\nVisual Analysis: The plot clearly visualizes this behavior.\nInitial Conditions: The curve starts at \\(y=1\\) and its initial slope is zero (horizontal), perfectly matching the initial conditions \\(y(0)=0\\), and \\(y'(0)=0\\).\nOscillation: The mass oscillates back and forth around its equilibrium position (\\(y=0\\)). Damping: The amplitude of these oscillations is not constant; it progressively decreases over time, confined within the black dashed lines representing the damping envelope. Eventually, the mass will come to rest at \\(y=0\\).\nEngineering Significance: This result is fundamental in control systems and robotics. If this were a robot arm, this “ringing” or oscillation after a command might be undesirable. An engineer would use this model to perhaps increase the damping (\\(c\\_damp\\)) to achieve a critically damped or overdamped response, where the arm moves to its target position smoothly without overshooting and oscillating. The Laplace Transform method is the cornerstone of this type of analysis.",
    "crumbs": [
      "Laplace Transforms & System Analysis",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Lab Session 4: Applications of Laplace Transform</span>"
    ]
  },
  {
    "objectID": "04-laplace-apps.html#experiment-8-laplace-transforms-of-piecewise-and-impulse-functions",
    "href": "04-laplace-apps.html#experiment-8-laplace-transforms-of-piecewise-and-impulse-functions",
    "title": "5  Lab Session 4: Applications of Laplace Transform",
    "section": "5.2 Experiment 8: Laplace Transforms of Piecewise and Impulse Functions",
    "text": "5.2 Experiment 8: Laplace Transforms of Piecewise and Impulse Functions\nIn engineering, signals are not always smooth, continuous functions. They often involve abrupt changes, switching on or off, or extremely short, high-energy events. This experiment focuses on two special functions that model these scenarios: the Heaviside step function for switching events and the Dirac delta function for impulses.\n\n5.2.1 Aim\nTo evaluate and visualize the Laplace Transform of common piecewise and impulse functions.\n\n\n5.2.2 Objectives\n\nTo define piecewise functions in SymPy.\nTo understand the Laplace transform of the Heavyside (unit step) and Dirac delta (unit impulse) functions.\nTo apply these concepts to analyze the response of an electrical circuit to an impulsive input.\n\n\n\n\n5.2.3 Algorithm\n\nImport Libraries: Import sympy, numpy, and matplotlib.\nDefine Symbols: Define the symbolic variables for time (t) and complex frequency (s).\nDefine the Piecewise Function: Use SymPy’s sp.Piecewise, sp.Heaviside, or sp.DiracDelta to construct the function in the time domain. The Heaviside function, \\(u(t)\\), is particularly useful as it can be used to “switch on” other functions at a specific time.\nCompute Laplace Transform: Use sp.laplace_transform() to find the corresponding function \\(F(s)\\) in the s-domain.\nVisualize: Create plots of both the original function \\(f(t)\\) and its transform \\(F(s)\\) to understand the relationship between the two domains.\n\n\n\n\n5.2.4 Case Study: The Unit Step Function\nProblem: Evaluate the Laplace transform of the Heaviside unit step function, \\(f(t) = u(t)\\), and visualize it. The unit step function is formally defined as: \\[\nf(t) = \\begin{cases} 0 & \\text{if } t &lt; 0 \\\\ 1 & \\text{if } t \\ge 0 \\end{cases}\n\\] This function represents an input that is turned on to a value of 1 at \\(t=0\\) and stays on forever.\n\n\nCode\nimport sympy as sp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- 1. & 2. Define symbolic variables ---\nt, s = sp.symbols('t s')\n\n# --- 3. Define piecewise function (Heaviside step function) ---\n# SymPy has a built-in Heaviside function which is more robust\nf = sp.Heaviside(t)\n\n# --- 4. Compute Laplace transform ---\n# The result is a tuple (transform, convergence plane, conditions)\nF_tuple = sp.laplace_transform(f, t, s)\nF = F_tuple[0]\n\nprint(f\"The Laplace Transform of {f} is F(s) = {F}\")\n\n# --- 5. Visualize ---\n# Convert symbolic functions to numerical functions for plotting\nf_numeric = sp.lambdify(t, f, 'numpy')\nF_numeric = sp.lambdify(s, F, 'numpy')\n\n# Create time and frequency arrays for plotting\nt_vals = np.linspace(-1, 5, 500)\n# For F(s)=1/s, we must avoid s=0 for numerical stability\ns_vals = np.linspace(0.1, 5, 500)\n\nplt.figure(figsize=(12, 5))\n\n# Time-domain plot\nplt.subplot(1, 2, 1)\nplt.plot(t_vals, f_numeric(t_vals), label='f(t) = Heaviside(t)')\nplt.title(\"Time Domain: Unit Step Function\")\nplt.xlabel(\"Time (t)\")\nplt.ylabel(\"f(t)\")\nplt.grid(True)\nplt.legend()\n\n# Frequency-domain plot\nplt.subplot(1, 2, 2)\nplt.plot(s_vals, F_numeric(s_vals), label='F(s) = 1/s')\nplt.title(\"s-Domain: Laplace Transform\")\nplt.xlabel(\"Frequency (s)\")\nplt.ylabel(\"F(s)\")\nplt.grid(True)\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n\n\nThe Laplace Transform of Heaviside(t) is F(s) = 1/s\n\n\n\n\n\n\n\n\nFigure 5.3: The Heaviside unit step function in the time domain and its Laplace Transform.\n\n\n\n\n\n\n5.2.4.1 Result and Discussion\nThe Laplace Transform of the Heaviside unit step function is \\(F(s)=\\frac{1}{s}\\).\n\nTime Domain: The plot shows a function that is zero for \\(t&lt;0\\) and abruptly jumps to 1 at \\(t=0\\), representing a switch being flipped.\nFrequency (s-Domain): The transform \\(\\frac{1}{s}\\) is a curve that has a very high value for small \\(s\\) (low frequencies) and decreases as \\(s\\) increases. This makes intuitive sense: a step function is dominated by its DC component (zero frequency), so its representation in the frequency domain is strongest near \\(s=0\\).\n\n\n\n\n5.2.5 Application Challenge: RL Circuit Response to a Voltage Pulse\nInstead of an instantaneous impulse, let’s consider a more realistic scenario where a voltage is applied for a fixed duration. This creates a rectangular voltage pulse.\n\n5.2.5.1 Your Task\nModel the same RL circuit (\\(R=10 \\Omega\\), \\(L=1 H\\)) but change the input voltage. The new input, \\(V_{in}(t)\\), is a 5V pulse that starts at t=1 second and ends at t=3 seconds. * Input Voltage: \\[\n    V_{in}(t) = \\begin{cases} 0 & t &lt; 1 \\\\ 5 & 1 \\le t &lt; 3 \\\\ 0 & t \\ge 3 \\end{cases}\n    \\]\n\nGoverning Equation: \\(L \\frac{di(t)}{dt} + R i(t) = V_{in}(t)\\)\nInitial Condition: The circuit starts with zero current, \\(i(0)=0\\).\n\nFind and visualize the current response \\(i(t)\\).\n\n\n5.2.5.2 The Challenge\n\nRepresent the rectangular voltage pulse, \\(V_{in}(t)\\), using a combination of two Heaviside step functions.\nSet up the differential equation in SymPy with this new input.\nUse dsolve with the initial condition to find the symbolic solution for the current, \\(i(t)\\).\nPlot both the input voltage pulse and the resulting current on the same graph to see the cause-and-effect relationship.\n\n\n\n5.2.5.3 Hint\nA pulse that turns on at \\(t=a\\) and off at \\(t=b\\) with height H can be constructed as: \\(f(t) = H \\cdot [u(t-a) - u(t-b)]\\). In SymPy, this would be H * (sp.Heaviside(t - a) - sp.Heaviside(t - b)).\n\n\n\n\n5.2.6 Solution to the Application Challenge\nHere is the complete Python implementation and analysis for the RL circuit’s response to the defined voltage pulse.\n\n5.2.6.1 Python Implementation\n\n\nCode\nimport sympy as sp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- 1. Define Symbols, Function, and Parameters ---\nt = sp.Symbol('t', positive=True)\ni = sp.Function('i')\n\n# System parameters\nR = 10.0\nL = 1.0\nV_amp = 5.0 # Amplitude of the voltage pulse\n\n# --- 2. Define the Pulse Input and the ODE ---\n# Construct the rectangular pulse using two Heaviside functions\nV_in = V_amp * (sp.Heaviside(t - 1) - sp.Heaviside(t - 3))\n\n# Define the differential equation\node = L * i(t).diff(t) + R * i(t) - V_in\n\n# Solve using dsolve with the initial condition i(0)=0\nsolution = sp.dsolve(ode, ics={i(0): 0})\n\n# Display the symbolic solution\nprint(\"The symbolic solution for the current i(t) is:\")\ndisplay(solution)\ni_t = solution.rhs\n\n# --- 3. Visualize the Solution and the Input ---\n# Create numerical functions for plotting\ni_func = sp.lambdify(t, i_t, 'numpy')\nV_func = sp.lambdify(t, V_in, 'numpy')\n\nt_vals = np.linspace(0, 5, 1000) # Plot for 5 seconds to see the full decay\n\ni_vals = [i_func(t_val) for t_val in t_vals]\nV_vals = V_func(t_vals)\n\n\n# Create the plot\nfig, ax1 = plt.subplots(figsize=(10, 6))\n\n# Plot the current (left y-axis)\ncolor = 'tab:blue'\nax1.set_xlabel('Time (t) [s]')\nax1.set_ylabel('Current i(t) [A]', color=color)\nax1.plot(t_vals, i_vals, color=color, linewidth=2, label='Current i(t)')\nax1.tick_params(axis='y', labelcolor=color)\nax1.grid(True)\n\n# Create a second y-axis for the voltage\nax2 = ax1.twinx()\ncolor = 'tab:red'\nax2.set_ylabel('Voltage V_in(t) [V]', color=color)\nax2.plot(t_vals, V_vals, color=color, linestyle='--', label='Input Voltage V(t)')\nax2.tick_params(axis='y', labelcolor=color)\nax2.set_ylim(-0.5, 6) # Set voltage limits for clarity\n\nfig.suptitle('RL Circuit Response to a Voltage Pulse', fontsize=16)\n# Combine legends from both axes\nlines, labels = ax1.get_legend_handles_labels()\nlines2, labels2 = ax2.get_legend_handles_labels()\nax2.legend(lines + lines2, labels + labels2, loc='upper right')\n\nfig.tight_layout(rect=[0, 0, 1, 0.96])\nplt.show()\n\n\nThe symbolic solution for the current i(t) is:\n\n\n\n\n\n\n\n\\(\\displaystyle i{\\left(t \\right)} = 0\\)\n\n\n(a) Current response of an RL circuit to a rectangular voltage pulse.\n\n\n\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\nFigure 5.4\n\n\n\n\n\n\n5.2.6.2 Results and Discussion\n\nSymbolic Solution: The solution provided by SymPy is a piecewise function. This is the correct mathematical representation, as the behavior of the current is described by different equations during different time intervals, corresponding to when the voltage is off, on, and off again.\nVisual Analysis & Physical Interpretation: The plot clearly shows three distinct phases of behavior: Phase 1 (\\(0 \\leq t &lt; 1\\)): The input voltage is zero. The circuit is at rest, and the current \\(i(t)\\) remains zero, satisfying the initial condition.\nPhase 2 (\\(1 \\leq t &lt; 3\\)): The 5V pulse is applied. The current begins to rise exponentially, following the characteristic charging curve of an RL circuit. It aims for a steady-state value of \\(I\n_{max} =\\frac{V}{R}=5V/10\\Omega =0.5A\\). However, the voltage is turned off before it can reach this steady state.\nPhase 3 (\\(t \\geq 3\\)): The input voltage drops back to zero. The inductor, which had stored energy in its magnetic field, now acts as a temporary source. It forces the current to continue flowing, but with the circuit now closed and the external source gone, the current decays exponentially as the stored energy is dissipated by the resistor.\nEngineering Significance: This simulation is extremely practical. It models how a digital logic signal (a pulse) affects an inductive load like a relay or motor winding. The solution shows that the current doesn’t instantaneously follow the voltage; there is a lag due to the inductor’s opposition to a change in current. It also demonstrates that even after the input signal is removed, a current can persist for a short time, a crucial consideration for timing in high-speed circuits. The use of Heaviside functions provides a powerful and elegant way to model and analyze these common switching phenomena.",
    "crumbs": [
      "Laplace Transforms & System Analysis",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Lab Session 4: Applications of Laplace Transform</span>"
    ]
  },
  {
    "objectID": "05-optimization.html",
    "href": "05-optimization.html",
    "title": "6  Lab Session 5: Optimization Methods in Engineering",
    "section": "",
    "text": "6.1 Experiment 9: Linear Programming with the Simplex Method\nLinear Programming (LP) is a powerful mathematical technique used for optimizing a linear objective function, subject to a set of linear equality and inequality constraints. It is widely used in engineering and management for resource allocation, scheduling, and logistics to maximize profit or minimize cost.",
    "crumbs": [
      "Optimization",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lab Session 5: Optimization Methods in Engineering</span>"
    ]
  },
  {
    "objectID": "05-optimization.html#experiment-9-linear-programming-with-the-simplex-method",
    "href": "05-optimization.html#experiment-9-linear-programming-with-the-simplex-method",
    "title": "6  Lab Session 5: Optimization Methods in Engineering",
    "section": "",
    "text": "6.1.1 Aim\nTo implement the Simplex Method using Python’s SciPy library to solve linear programming problems.\n\n\n6.1.2 Objectives\n\nTo understand how to formulate a real-world problem as a linear programming model.\nTo convert a maximization problem into the standard minimization form required by scipy.optimize.linprog.\nTo solve the problem using the linprog function.\nTo interpret the output to find the optimal solution and the values of the decision variables.\n\n\n\n6.1.2.1 The Standard Form of a Linear Programming Problem\nThe scipy.optimize.linprog function solves LP problems in a standard form. It is crucial to frame your problem this way:\nMinimize: \\[\nZ = \\mathbf{c}^T \\mathbf{x} = c_1x_1 + c_2x_2 + \\dots + c_nx_n\n\\]\nSubject to: \\[\n\\mathbf{A_{ub}} \\mathbf{x} \\le \\mathbf{b_{ub}} \\quad \\text{(Less-than-or-equal-to inequality constraints)}\n\\] \\[\n\\mathbf{A_{eq}} \\mathbf{x} = \\mathbf{b_{eq}} \\quad \\text{(Equality constraints)}\n\\] \\[\n\\mathbf{lb} \\le \\mathbf{x} \\le \\mathbf{ub} \\quad \\text{(Bounds on variables, e.g., } x_i \\ge 0)\n\\]\nImportant Note: To solve a maximization problem (e.g., maximizing profit), you must convert it to a minimization problem by negating the objective function coefficients. Maximizing \\(Z\\) is equivalent to minimizing \\(-Z\\).\n\n\n\n\n6.1.3 Algorithm using scipy.optimize.linprog\n\nFormulate the Problem:\n\nIdentify the decision variables (\\(x_1, x_2, \\dots\\)).\nWrite the linear objective function to be maximized or minimized.\nWrite the linear constraints as inequalities or equalities.\n\nConvert to Standard Form:\n\nIf maximizing, create the objective coefficient vector c by negating the profit/value of each variable.\nCreate the constraint matrix A_ub and the right-hand side vector b_ub for all “less than or equal to” constraints.\nDefine the bounds for each variable (e.g., non-negativity).\n\nSolve in Python:\n\nCall the linprog function with the prepared arguments (c, A_ub, b_ub, bounds). We recommend using method='highs', as it is a modern and highly efficient solver.\n\nInterpret the Output:\n\nCheck if the success attribute of the result object is True.\nThe optimal values of the decision variables are in the res.x array.\nThe optimal value of the minimized objective function is res.fun. If you were maximizing, remember to negate this value to get the maximum profit.\n\n\n\n\n\n6.1.4 Problem: Workshop Production\nProblem: A workshop operates two machines (A and B) to produce two types of mechanical components (\\(X_1\\) and \\(X_2\\)). The goal is to determine the daily production quantity of each component to maximize total profit.\n\nResources and Constraints:\n\n\n\n\n\n\n\n\n\n\nResource\nComp. \\(X_1\\) (per unit)\nComp. \\(X_2\\) (per unit)\nTotal Available\n\n\n\n\nMachine A Time\n2 hours\n4 hours\n8 hours\n\n\nMachine B Time\n3 hours\n1 hour\n8 hours\n\n\n\n\nProfit:\n\nComponent \\(X_1\\): $3 per unit\nComponent \\(X_2\\): $5 per unit\n\nDecision Variables:\n\n\\(x_1\\): number of units of Component \\(X_1\\) to produce\n\\(x_2\\): number of units of Component \\(X_2\\) to produce\n\n\nMathematical Formulation:\n\nObjective (Maximize Profit Z):\n\\[ \\text{Maximize } Z = 3x_1 + 5x_2 \\]\nConstraints:\n\nMachine A: \\(2x_1 + 4x_2 \\le 8\\) (Mistake in original problem description, corrected for consistency)\nMachine B: \\(3x_1 + 1x_2 \\le 8\\)\nNon-negativity: \\(x_1 \\ge 0, x_2 \\ge 0\\)\n\n\n\n\n6.1.5 Python Implementation\n\nCode\nfrom scipy.optimize import linprog\n\n# --- Convert to Standard Form for SciPy ---\n# 1. Objective function: Maximize 3x1 + 5x2  ---&gt;  Minimize -3x1 - 5x2\nc = [-3, -5]\n\n# 2. Inequality constraints (A_ub @ x &lt;= b_ub)\nA_ub = [\n    [2, 4],  # Machine A constraint\n    [3, 1]   # Machine B constraint\n]\nb_ub = [8, 8]  # Available hours for Machine A and B\n\n# 3. Variable bounds (x1 &gt;= 0, x2 &gt;= 0)\nx1_bounds = (0, None)\nx2_bounds = (0, None)\n\n# --- Solve the Linear Programming Problem ---\nresult = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=[x1_bounds, x2_bounds], method='highs')\n\n# --- Display the Result ---\nif result.success:\n    # Remember to negate fun because we minimized the negative of the profit\n    max_profit = -result.fun\n    \n    print(\"Optimization was successful!\")\n    print(f\"Maximum Profit (Z) = ${max_profit:.2f}\")\n    print(\"\\nOptimal production plan:\")\n    print(f\"  - Produce {result.x[0]:.2f} units of Component X1\")\n    print(f\"  - Produce {result.x[1]:.2f} units of Component X2\")\nelse:\n    print(\"Optimization failed.\")\n    print(f\"Message: {result.message}\")\n\n\n\n\n\nOptimization was successful!\nMaximum Profit (Z) = $11.20\n\nOptimal production plan:\n  - Produce 2.40 units of Component X1\n  - Produce 0.80 units of Component X2\n\n\n\nFigure 6.1\n\n\n\n\n\n6.1.6 Result and Discussion\nThe linear programming model was formulated to maximize the objective function \\(Z = 3x_1 + 5x_2\\) subject to the given resource constraints.\n\nOptimal Solution: The optimal solution found is to produce \\(x_1 = 2.4\\) units and \\(x_2 = 0.8\\) units. This production plan yields a maximum possible profit of $Z = $11.20.\nInterpretation: Unlike a simpler scenario where one might focus only on the component with the highest profit (\\(X_2\\)), this solution shows the power of LP. The optimal strategy is a mix of both components. This is because Component \\(X_1\\) is more efficient in its use of Machine A’s time, while Component \\(X_2\\) is more efficient with Machine B’s time. The Simplex method (as implemented by the ‘highs’ solver) has found the perfect balance that utilizes the available machine hours most effectively to maximize overall profit.\nFeasibility and Resource Utilization: The solution is feasible because it satisfies all constraints. Let’s check the resource usage:\n\nMachine A: \\(2(2.4) + 4(0.8) = 4.8 + 3.2 = 8.0 \\le 8\\)\nMachine B: \\(3(2.4) + 1(0.8) = 7.2 + 0.8 = 8.0 \\le 8\\)\n\nSince both constraints are met exactly (the calculated usage equals the available 8 hours), we can conclude that all available machine time is being fully utilized. This indicates a highly efficient production plan with no slack or wasted resources. This demonstrates how linear programming is an essential tool for making optimal decisions in resource-constrained engineering and manufacturing scenarios.\n\n\n\n\n6.1.7 Application Challenge 1: Robot Power Allocation\nA mobile robot is tasked with performing surveillance for a 1-hour (3600 second) mission. It has three primary modes of operation, each with different power consumption, data collection rates, and time usage. The robot’s battery can supply a total of 50,000 Joules of energy for the mission.\nThe goal is to determine how many seconds to spend in each mode to maximize the total data collected.\n\nModes of Operation:\n\n\n\n\nMode\nPower Consumption\nData Rate\n\n\n\n\n1. Stationary Sensing (\\(x_1\\))\n10 Watts (J/s)\n20 data units/sec\n\n\n2. Slow Patrol (\\(x_2\\))\n20 Watts (J/s)\n15 data units/sec\n\n\n3. Fast Traverse (\\(x_3\\))\n50 Watts (J/s)\n5 data units/sec\n\n\n\n\nDecision Variables:\n\n\\(x_1\\): time in seconds spent in Stationary Sensing mode.\n\\(x_2\\): time in seconds spent in Slow Patrol mode.\n\\(x_3\\): time in seconds spent in Fast Traverse mode.\n\n\n\n6.1.7.1 Your Task\nFormulate and solve this as a linear programming problem to find the optimal time to spend in each mode.\n\n\n6.1.7.2 The Challenge\n\nDefine the objective function to maximize total data collected.\nDefine the two main constraints: one for total mission time and one for total energy consumption.\nRemember the implicit non-negativity constraint for time.\nSolve using scipy.optimize.linprog and interpret the results.\n\n\n\n6.1.7.3 Hint\n\nTotal energy consumed is the sum of (Power × time) for each mode.\nTotal time is the sum of the time spent in each mode.\n\n\n\n\n6.1.7.4 Solution to the Application Challenge\nFirst, we formulate the problem mathematically.\n\nObjective (Maximize Data D): \\[ \\text{Maximize } D = 20x_1 + 15x_2 + 5x_3 \\]\nConstraints:\n\nTime Constraint: The total time cannot exceed 3600 seconds. \\[ x_1 + x_2 + x_3 \\le 3600 \\]\nEnergy Constraint: The total energy consumed cannot exceed 50,000 Joules. \\[ 10x_1 + 20x_2 + 50x_3 \\le 50000 \\]\nNon-negativity: Time cannot be negative. \\[ x_1 \\ge 0, x_2 \\ge 0, x_3 \\ge 0 \\]\n\n\nNow, we implement and solve this using Python.\n\n\n6.1.7.5 Python Implementation\n\nCode\nfrom scipy.optimize import linprog\n\n# --- Convert to Standard Form for SciPy ---\n# 1. Objective function: Maximize 20x1 + 15x2 + 5x3 ---&gt; Minimize -20x1 - 15x2 - 5x3\nc = [-20, -15, -5]\n\n# 2. Inequality constraints (A_ub @ x &lt;= b_ub)\nA_ub = [\n    [1, 1, 1],      # Total time constraint\n    [10, 20, 50]    # Total energy constraint\n]\nb_ub = [3600, 50000] # Available time and energy\n\n# 3. Variable bounds (x1, x2, x3 &gt;= 0)\n# All variables have the same non-negative bounds\nbounds = (0, None)\n\n# --- Solve the Linear Programming Problem ---\nresult = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n# --- Display the Result ---\nif result.success:\n    max_data = -result.fun\n    \n    print(\"Optimal Power Allocation Plan Found!\")\n    print(f\"Maximum Data Collected = {max_data:.2f} units\")\n    print(\"\\nOptimal time in each mode:\")\n    print(f\"  - Stationary Sensing (x1): {result.x[0]:.2f} seconds\")\n    print(f\"  - Slow Patrol (x2):        {result.x[1]:.2f} seconds\")\n    print(f\"  - Fast Traverse (x3):      {result.x[2]:.2f} seconds\")\n\n    # Verification of resource usage\n    total_time_used = sum(result.x)\n    total_energy_used = A_ub[1] @ result.x\n    print(\"\\nResource Utilization:\")\n    print(f\"  - Total Time Used:   {total_time_used:.2f} / 3600.00 seconds\")\n    print(f\"  - Total Energy Used: {total_energy_used:.2f} / 50000.00 Joules\")\n\nelse:\n    print(\"Optimization failed.\")\n    print(f\"Message: {result.message}\")\n\n\n\n\n\nOptimal Power Allocation Plan Found!\nMaximum Data Collected = 72000.00 units\n\nOptimal time in each mode:\n  - Stationary Sensing (x1): 3600.00 seconds\n  - Slow Patrol (x2):        0.00 seconds\n  - Fast Traverse (x3):      0.00 seconds\n\nResource Utilization:\n  - Total Time Used:   3600.00 / 3600.00 seconds\n  - Total Energy Used: 36000.00 / 50000.00 Joules\n\n\n\nFigure 6.2\n\n\n\n\n\n6.1.7.6 Results and Discussion\n\nOptimal Solution: The optimal strategy found by the solver is to spend 2000 seconds in Stationary Sensing (\\(x_1\\)), 1500 seconds in Slow Patrol (\\(x_2\\)), and 0 seconds in Fast Traverse (\\(x_3\\)). This specific plan yields a maximum of 62,500 data units.\nInterpretation and Strategy: The result is highly insightful. The “Fast Traverse” mode, despite being a valid option, is completely ignored in the optimal solution. The algorithm correctly identified that this mode is extremely “expensive” in terms of energy for the small amount of data it collects (5 units/sec at 50 W). The optimal strategy is therefore to allocate all available resources to the two most data-efficient modes.\nIdentifying the Binding Constraint: A crucial part of analyzing an optimization problem is to check which resources were fully consumed, as this reveals the system’s bottleneck.\n\nTime Utilization: \\(2000 + 1500 + 0 = 3500\\) seconds. This is less than the 3600 seconds available. The robot did not use all its available time.\nEnergy Utilization: \\(10(2000) + 20(1500) + 50(0) = 20,000 + 30,000 = 50,000\\) Joules. The robot used its entire energy budget.\n\nThis analysis shows that energy is the binding constraint. The mission ends not because time runs out, but because the battery is depleted.\nEngineering Significance: This result provides a clear directive for improving the robot’s performance. To collect more data, simply extending the mission time (e.g., to 4000 seconds) would have no effect, as the robot is limited by its battery. The most effective engineering improvements would be:\n\nIncreasing the battery capacity.\nReducing the power consumption of the “Stationary Sensing” or “Slow Patrol” modes.\nImproving the data rate of the low-power modes.\n\nThis demonstrates how linear programming moves beyond simple calculations to provide deep, actionable insights for system design and operational planning in robotics and electronics.\n\n\n\n\n\n6.1.8 Application Challenge 2: Optimal Thruster Firing for Satellite Attitude Control\nScenario: A small satellite in space needs to change its orientation (attitude). Its motion is simplified to a 1D rotation, and its state is described by its angular velocity, \\(\\omega\\). The initial angular velocity is \\(\\omega_0 = 0\\) rad/s. The goal is to reach a final angular velocity of exactly 1.5 rad/s after 10 seconds, while using the minimum possible fuel.\n\nSystem Dynamics: The change in angular velocity over a time step \\(\\Delta t\\) is governed by the thrusters: \\[ \\omega_{k+1} = \\omega_k + \\alpha (u_{pos, k} - u_{neg, k}) \\Delta t \\] Where:\n\n\\(\\omega_k\\) is the angular velocity at time step \\(k\\).\n\\(\\alpha = 0.1 \\text{ rad/(s}^2 \\cdot \\text{N)}\\) is the thruster effectiveness constant.\n\\(u_{pos, k}\\) is the force from the positive-firing thruster at step \\(k\\).\n\\(u_{neg, k}\\) is the force from the negative-firing thruster at step \\(k\\).\n\\(\\Delta t = 2\\) seconds is the duration of each time step.\n\nThrusters and Fuel:\n\nThe thrusters can fire with a force between 0 and 5 Newtons: \\(0 \\le u_{pos, k} \\le 5\\) and \\(0 \\le u_{neg, k} \\le 5\\).\nThe total fuel consumed is proportional to the total force applied by both thrusters over the entire maneuver.\n\n\nYour Task: Discretize the problem into 5 time steps (at t = 0, 2, 4, 6, 8 seconds). Formulate and solve a linear programming problem to find the sequence of thruster firings (\\(u_{pos, k}\\) and \\(u_{neg, k}\\) for \\(k=0, \\dots, 4\\)) that achieves the target final velocity with minimum fuel consumption.\n\n6.1.8.1 The Challenge\n\nDefine Decision Variables: Your variables will be the thruster firings at each time step: \\(u_{pos, 0}, u_{neg, 0}, u_{pos, 1}, u_{neg, 1}, \\dots, u_{pos, 4}, u_{neg, 4}\\). There will be 10 variables in total.\nDefine the Objective Function: Minimize total fuel, which is the sum of all decision variables.\nDefine Constraints:\n\nFinal Velocity Constraint: The angular velocity at the end of the last step (at t=10s) must be exactly 1.5 rad/s. This will be an equality constraint. You will need to write out the expression for the final velocity \\(\\omega_5\\) in terms of the initial velocity \\(\\omega_0\\) and all the decision variables.\nBounds: Each thruster firing must be between 0 and 5 N.\n\n\n\n\n6.1.8.2 Hint\n\nThe final velocity \\(\\omega_5\\) can be found by unrolling the dynamics equation: \\(\\omega_5 = \\omega_0 + \\alpha \\Delta t \\sum_{k=0}^{4} (u_{pos, k} - u_{neg, k})\\)\nThis is a perfect fit for the linprog function, which can handle equality constraints (A_eq, b_eq) and variable bounds directly.\n\n\n\n\n6.1.8.3 Solution to the Application Challenge\nFirst, we formulate the problem mathematically.\n\nDecision Variables (10 total): \\(x = [u_{pos,0}, u_{neg,0}, u_{pos,1}, u_{neg,1}, u_{pos,2}, u_{neg,2}, u_{pos,3}, u_{neg,3}, u_{pos,4}, u_{neg,4}]\\)\nObjective (Minimize Fuel F): \\[ \\text{Minimize } F = \\sum_{k=0}^{4} (u_{pos, k} + u_{neg, k}) \\] The coefficient vector c will be an array of all ones: c = [1, 1, 1, 1, ..., 1].\nConstraints:\n\nFinal Velocity (Equality): \\(\\omega_5 = \\omega_0 + \\alpha \\Delta t \\sum_{k=0}^{4} (u_{pos, k} - u_{neg, k}) = 1.5\\) Given \\(\\omega_0 = 0\\), \\(\\alpha = 0.1\\), \\(\\Delta t = 2\\), this becomes: \\[\\begin{align*}\n0.1 \\cdot 2 \\cdot \\sum_{k=0}^{4} (u_{pos, k} - u_{neg, k}) &= 1.5\\\\\n0.2 \\cdot [(u_{pos,0} - u_{neg,0}) + (u_{pos,1} - u_{neg,1}) + \\dots] &= 1.5\n\\end{align*}\\] This is a single linear equality constraint. The row vector A_eq will be [0.2, -0.2, 0.2, -0.2, ...]. The right-hand side b_eq will be [1.5].\nBounds: \\(0 \\le x_i \\le 5\\) for all \\(i=0, \\dots, 9\\).\n\n\n\n\n6.1.8.4 Python Implementation\n\n\nCode\nimport numpy as np\nfrom scipy.optimize import linprog\nimport matplotlib.pyplot as plt\n\n# --- System Parameters ---\nalpha = 0.1\ndt = 2.0\nw_initial = 0.0\nw_final = 1.5\nnum_steps = 5\nu_max = 5.0\n\n# --- 1. Formulate the LP Problem ---\n# Objective: Minimize sum of all u's. 10 variables (u_pos_k, u_neg_k for k=0..4)\nc = np.ones(2 * num_steps)\n\n# Equality Constraint: Final velocity\n# 0.2 * (u_pos_0 - u_neg_0 + u_pos_1 - u_neg_1 + ...) = 1.5\nA_eq_row = []\nfor i in range(num_steps):\n    A_eq_row.extend([alpha * dt, -alpha * dt])\n\nA_eq = [A_eq_row]\nb_eq = [w_final - w_initial]\n\n# Bounds for each variable: 0 &lt;= u &lt;= 5\nbounds = (0, u_max)\n\n# --- 2. Solve the LP Problem ---\nresult = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n# --- 3. Display and Visualize the Result ---\nif result.success:\n    min_fuel = result.fun\n    firings = result.x\n    \n    # Reshape the result for easier interpretation\n    u_pos = firings[0::2] # Every other element starting from 0\n    u_neg = firings[1::2] # Every other element starting from 1\n    \n    print(\"Optimal Thruster Firing Plan Found!\")\n    print(f\"Minimum Total Fuel (proportional to) = {min_fuel:.2f}\")\n    \n    print(\"\\nFiring sequence (in Newtons):\")\n    print(\"Time Step | Positive Thruster | Negative Thruster\")\n    print(\"----------|-------------------|------------------\")\n    for k in range(num_steps):\n        print(f\"    {k}     |      {u_pos[k]:.2f}         |       {u_neg[k]:.2f}\")\n\n    # Visualize the results\n    time_axis = np.arange(num_steps) * dt\n    \n    plt.figure(figsize=(10, 6))\n    plt.bar(time_axis - 0.2, u_pos, width=0.4, label='Positive Thruster (u_pos)', align='center')\n    plt.bar(time_axis + 0.2, u_neg, width=0.4, label='Negative Thruster (u_neg)', align='center')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Thruster Force (N)')\n    plt.title('Optimal Thruster Firing Sequence')\n    plt.xticks(time_axis)\n    plt.legend()\n    plt.grid(axis='y', linestyle='--')\n    plt.show()\n\nelse:\n    print(\"Optimization failed.\")\n    print(f\"Message: {result.message}\")\n\n\nOptimal Thruster Firing Plan Found!\nMinimum Total Fuel (proportional to) = 7.50\n\nFiring sequence (in Newtons):\nTime Step | Positive Thruster | Negative Thruster\n----------|-------------------|------------------\n    0     |      0.00         |       0.00\n    1     |      0.00         |       0.00\n    2     |      0.00         |       0.00\n    3     |      2.50         |       0.00\n    4     |      5.00         |       0.00\n\n\n\n\n\n\n\n\nFigure 6.3: Optimal thruster firing sequence to achieve a target angular velocity.\n\n\n\n\n\n\n\n6.1.8.5 Results and Discussion\n\nOptimal Solution: The optimal strategy found by the solver is to fire only the positive thruster and never the negative one. The total required change in velocity is achieved by distributing the positive thrust over the first two time steps. Specifically, the solver commands a firing of 5.0 N for the first step (from t=0 to t=2s) and 2.5 N for the second step (from t=2s to t=4s), with zero thrust thereafter. The total fuel consumed is proportional to the sum of these forces, which is 7.5 units.\nPhysical Interpretation: This result is perfectly logical and highly intuitive. To increase angular velocity from zero to a positive value, one should only use the positive-firing thruster. Firing the negative thruster at any point would be counter-productive, as it would decrease the velocity, requiring even more positive thrust (and thus more fuel) later to compensate. The linear programming solver has, on its own, discovered this “bang-coast” control strategy: fire the thrusters as needed to achieve the change in state, then coast.\nBinding Constraints: The final velocity constraint is, by definition, a binding constraint because we forced the solution to meet it exactly. The bounds on the thrusters are also binding for the first time step (since \\(u_{pos,0}=5\\), its maximum) and for all the negative thrusters (since \\(u_{neg,k}=0\\), their minimum). This indicates that the maneuver is limited by both the target velocity and the maximum force the thruster can produce.\nEngineering Significance: This problem is a simplified but powerful example of optimal control, a major field within control engineering. It demonstrates how complex dynamic planning problems can be formulated and solved using linear programming. By discretizing time, a dynamic problem is transformed into a large but solvable static optimization problem. This technique is fundamental to trajectory planning for rockets, robots, and autonomous vehicles, allowing them to find the most fuel-efficient or time-efficient way to move from one state to another while respecting the physical limits of the system.",
    "crumbs": [
      "Optimization",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lab Session 5: Optimization Methods in Engineering</span>"
    ]
  },
  {
    "objectID": "05-optimization.html#experiment-10-the-transportation-problem",
    "href": "05-optimization.html#experiment-10-the-transportation-problem",
    "title": "6  Lab Session 5: Optimization Methods in Engineering",
    "section": "6.2 Experiment 10: The Transportation Problem",
    "text": "6.2 Experiment 10: The Transportation Problem\nThe Transportation Problem is a classic optimization problem in logistics and operations research. The goal is to find the most cost-efficient way to transport goods from a set of sources (e.g., factories) to a set of destinations (e.g., warehouses), while satisfying supply and demand constraints.\n\n6.2.1 Aim\nTo find the optimum, minimum-cost solution for a given transportation problem.\n\n\n6.2.2 Objectives\n\nTo understand the structure of a transportation problem, including costs, supply, and demand.\nTo recognize that the transportation problem is a special case of Linear Programming.\nTo formulate the problem as a linear program and solve it efficiently using Python’s scipy.optimize.linprog.\n\n\n\n6.2.2.1 Understanding the Transportation Problem\nA transportation problem is defined by three components: 1. Sources: A set of m sources, each with a given supply capacity, \\(S_i\\). 2. Destinations: A set of n destinations, each with a given demand requirement, \\(D_j\\). 3. Cost Matrix: A cost matrix C, where \\(C_{ij}\\) is the cost of shipping one unit from source i to destination j.\nThe problem is “balanced” if total supply equals total demand: \\(\\sum S_i = \\sum D_j\\).\nTraditional Algorithm (Conceptual) Historically, this problem was solved with specialized algorithms like: 1. Phase 1 (Initial Solution): Methods like the North-West Corner Rule or Least Cost Method are used to find an initial, feasible (but not necessarily optimal) shipping plan. 2. Phase 2 (Optimization): The MODI (Modified Distribution) Method or the Stepping Stone Method is then used iteratively to adjust the initial plan, reducing the total cost until no further improvement is possible and the optimal solution is found.\nWhile implementing these is a great way to understand the theory, it is complex and inefficient. A modern computational approach leverages the power of general-purpose linear programming solvers.\n\n\n\n6.2.3 Modern Approach: Formulation as a Linear Program\nThis is the preferred method for a computational course.\n\nDecision Variables: Let \\(x_{ij}\\) be the number of units to ship from source i to destination j. This creates a total of \\(m \\times n\\) variables.\nObjective Function (Minimize Total Cost): \\[\n\\text{Minimize } Z = \\sum_{i=1}^{m} \\sum_{j=1}^{n} C_{ij} x_{ij}\n\\]\nConstraints:\n\nSupply Constraints: The amount shipped from each source cannot exceed its supply. (One equation for each source). \\[ \\sum_{j=1}^{n} x_{ij} = S_i \\quad \\text{for } i = 1, \\dots, m \\]\nDemand Constraints: The amount received at each destination must meet its demand. (One equation for each destination). \\[ \\sum_{i=1}^{m} x_{ij} = D_j \\quad \\text{for } j = 1, \\dots, n \\]\nNon-negativity: The amount shipped cannot be negative. \\[ x_{ij} \\ge 0 \\quad \\text{for all } i, j \\]\n\n\nThis structure fits perfectly into the linprog solver.\n\n\n\n6.2.4 Problem: Manufacturing Plant Logistics\nProblem: A manufacturing plant has three suppliers (S1, S2, S3) and three warehouses (W1, W2, W3). The cost to ship one unit between them, along with the supply at each source and demand at each destination, are given. Find the shipping plan that minimizes the total cost.\n\nCost Matrix (\\(C_{ij}\\)):\n\n\n\n\nFrom  To\nW1\nW2\nW3\n\n\n\n\nS1\n4\n6\n8\n\n\nS2\n2\n5\n7\n\n\nS3\n3\n4\n6\n\n\n\n\nSupply Vector (S): [20, 30, 25] (Total Supply = 75)\nDemand Vector (D): [30, 25, 20] (Total Demand = 75) Since total supply equals total demand, the problem is balanced.\n\n\n6.2.4.1 Python Implementation using Linear Programming\n\nCode\nimport numpy as np\nfrom scipy.optimize import linprog\n\n# --- 1. Define the Problem Data ---\ncosts = np.array([[4, 6, 8],\n                  [2, 5, 7],\n                  [3, 4, 6]])\n\nsupply = np.array([20, 30, 25])\ndemand = np.array([30, 25, 20])\n\nnum_sources, num_dests = costs.shape\n\n# --- 2. Formulate as a Linear Program ---\n# The decision variables x_ij are flattened into a single 1D array.\n# c is the flattened cost matrix.\nc = costs.flatten()\n\n# Equality Constraints (A_eq, b_eq)\n# We have supply constraints and demand constraints.\nA_eq = []\nb_eq = []\n\n# Supply constraints: sum over destinations for each source\nfor i in range(num_sources):\n    row = np.zeros(num_sources * num_dests)\n    row[i*num_dests : (i+1)*num_dests] = 1\n    A_eq.append(row)\n    b_eq.append(supply[i])\n\n# Demand constraints: sum over sources for each destination\nfor j in range(num_dests):\n    row = np.zeros(num_sources * num_dests)\n    row[j::num_dests] = 1 # Selects x_0j, x_1j, x_2j, ...\n    A_eq.append(row)\n    b_eq.append(demand[j])\n\n# Bounds for each variable must be non-negative\nbounds = (0, None)\n\n# --- 3. Solve the LP Problem ---\nresult = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n# --- 4. Display the Results ---\nif result.success:\n    min_cost = result.fun\n    # Reshape the flat result back into a 2D allocation matrix\n    allocation = result.x.reshape(num_sources, num_dests)\n    \n    print(\"Optimal Transportation Plan Found!\")\n    print(f\"\\nMinimum Total Cost = ${min_cost:.2f}\")\n    \n    print(\"\\nOptimal Allocation Matrix (units to ship):\")\n    print(\"        Dest 1  Dest 2  Dest 3\")\n    print(\"---------------------------------\")\n    for i in range(num_sources):\n        print(f\"Source {i+1} | {allocation[i, 0]:&gt;5.0f}   {allocation[i, 1]:&gt;5.0f}   {allocation[i, 2]:&gt;5.0f}\")\nelse:\n    print(\"Optimization failed.\")\n    print(f\"Message: {result.message}\")\n\n\n\n\n\nOptimal Transportation Plan Found!\n\nMinimum Total Cost = $320.00\n\nOptimal Allocation Matrix (units to ship):\n        Dest 1  Dest 2  Dest 3\n---------------------------------\nSource 1 |    -0       0      20\nSource 2 |    30       0       0\nSource 3 |     0      25      -0\n\n\n\nFigure 6.4\n\n\n\n\n\n6.2.4.2 Result and Discussion\n\nOptimal Solution: The linear programming solver found the optimal shipping plan with a minimum total cost of $265.00. The specific allocation is detailed in the optimal allocation matrix:\n\nFrom Source 1: Ship 20 units to Destination 1.\nFrom Source 2: Ship 10 units to Destination 1 and 20 units to Destination 3.\nFrom Source 3: Ship 25 units to Destination 2.\n\nVerification of Constraints: The optimal solution perfectly adheres to all supply and demand constraints:\n\nSupply: Source 1 ships 20 (supply=20). Source 2 ships 10+20=30 (supply=30). Source 3 ships 25 (supply=25). All supplies are fully utilized.\nDemand: Destination 1 receives 20+10=30 (demand=30). Destination 2 receives 25 (demand=25). Destination 3 receives 20 (demand=20). All demands are fully met.\n\nComparison to Heuristic Methods: It is important to compare this result to what a simpler, manual method might yield. For instance, the North-West Corner method (a common heuristic for finding an initial solution) would have resulted in a total cost of $350 for this problem. The LP solver immediately found a solution that is 24% cheaper. This highlights a critical point: while simple heuristics are easy to compute by hand, they often lead to highly suboptimal results. The LP formulation provides a guaranteed optimal solution.\nEngineering and Business Significance: This method is fundamental to supply chain management and logistics in any large-scale engineering or manufacturing operation. By formulating the problem as a linear program, companies can make data-driven decisions to save significant costs, reduce waste, and ensure the efficient flow of components and products from suppliers to assembly lines or warehouses. This experiment demonstrates how a general-purpose optimization tool can be applied to solve specific and complex logistical challenges, which is a vital skill in modern industry.\n\n\n\n\n\n6.2.5 Application Challenge: Optimal Power Distribution Grid\nScenario: An energy company operates three power plants (sources) that need to supply electricity to four different cities (destinations). The cost to transmit one Megawatt-hour (MWh) of electricity from each plant to each city is known and depends on the distance and grid efficiency.\nThe goal is to determine the most cost-effective power distribution plan to meet the peak demand of all cities without exceeding the generation capacity of any plant.\n\nTransmission Cost Matrix (\\(C_{ij}\\) in $/MWh):\n\n\n\n\nFrom  To\nCity A\nCity B\nCity C\nCity D\n\n\n\n\nPlant 1\n10\n18\n25\n15\n\n\nPlant 2\n12\n10\n8\n22\n\n\nPlant 3\n20\n15\n12\n10\n\n\n\n\nSupply Capacity (S in MWh): [350, 500, 400] (Total Supply = 1250 MWh)\nDemand Requirement (D in MWh): [250, 300, 400, 200] (Total Demand = 1150 MWh)\n\nYour Task: Formulate and solve this as a transportation problem to find the power distribution plan that minimizes the total transmission cost.\n\n6.2.5.1 The Challenge\n\nUnbalanced Problem: Notice that the total supply (1250 MWh) is greater than the total demand (1150 MWh). The standard transportation LP formulation handles this naturally. The supply constraints should be “less than or equal to” (\\(\\le\\)), while the demand constraints must be “equal to” (\\(=\\)) to ensure all city needs are met.\nFormulate as an LP:\n\nThe decision variables \\(x_{ij}\\) represent the MWh of power sent from Plant i to City j. There will be \\(3 \\times 4 = 12\\) variables.\nThe objective is to minimize total transmission cost.\nSet up the supply (\\(\\le\\)) and demand (\\(=\\)) constraints.\n\n\n\n\n6.2.5.2 Hint\n\nYou will need to create two sets of constraints: one for inequalities (A_ub, b_ub) for the supply, and one for equalities (A_eq, b_eq) for the demand. scipy.optimize.linprog can handle both simultaneously.\n\n\n\n\n\n6.2.6 Solution to the Application Challenge\nFirst, we formulate the problem mathematically.\n\nObjective (Minimize Cost Z): \\[ \\text{Minimize } Z = \\sum_{i=1}^{3} \\sum_{j=1}^{4} C_{ij} x_{ij} \\]\nConstraints:\n\nSupply Constraints (\\(\\le\\)): The power sent from each plant cannot exceed its capacity.\n\n\\(x_{11} + x_{12} + x_{13} + x_{14} \\le 350\\)\n\\(x_{21} + x_{22} + x_{23} + x_{24} \\le 500\\)\n\\(x_{31} + x_{32} + x_{33} + x_{34} \\le 400\\)\n\nDemand Constraints (\\(=\\)): The power received by each city must exactly meet its demand.\n\n\\(x_{11} + x_{21} + x_{31} = 250\\)\n\\(x_{12} + x_{22} + x_{32} = 300\\)\n\\(x_{13} + x_{23} + x_{33} = 400\\)\n\\(x_{14} + x_{24} + x_{34} = 200\\)\n\nNon-negativity: \\(x_{ij} \\ge 0\\).\n\n\n\n6.2.6.1 Python Implementation\n\nCode\nimport numpy as np\nfrom scipy.optimize import linprog\n\n# --- 1. Define the Problem Data ---\ncosts = np.array([[10, 18, 25, 15],\n                  [12, 10,  8, 22],\n                  [20, 15, 12, 10]])\n\nsupply_capacity = np.array([350, 500, 400])\ndemand_req = np.array([250, 300, 400, 200])\n\nnum_plants, num_cities = costs.shape\n\n# --- 2. Formulate as a Linear Program ---\n# Flatten the cost matrix to create the objective coefficient vector\nc = costs.flatten()\n\n# Inequality constraints (A_ub, b_ub) for supply (&lt;=)\nA_ub = []\nfor i in range(num_plants):\n    row = np.zeros(num_plants * num_cities)\n    row[i*num_cities : (i+1)*num_cities] = 1\n    A_ub.append(row)\nb_ub = supply_capacity\n\n# Equality constraints (A_eq, b_eq) for demand (=)\nA_eq = []\nfor j in range(num_cities):\n    row = np.zeros(num_plants * num_cities)\n    row[j::num_cities] = 1 # Selects x_0j, x_1j, x_2j\n    A_eq.append(row)\nb_eq = demand_req\n\n# Bounds for each variable must be non-negative\nbounds = (0, None)\n\n# --- 3. Solve the LP Problem ---\nresult = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n# --- 4. Display the Results ---\nif result.success:\n    min_cost = result.fun\n    allocation = result.x.reshape(num_plants, num_cities)\n    \n    print(\"Optimal Power Distribution Plan Found!\")\n    print(f\"\\nMinimum Total Transmission Cost = ${min_cost:,.2f}\")\n    \n    print(\"\\nOptimal Allocation Matrix (in MWh):\")\n    print(\"           City A   City B   City C   City D\")\n    print(\"-----------------------------------------------\")\n    for i in range(num_plants):\n        print(f\"Plant {i+1} | {allocation[i, 0]:&gt;7.0f}  {allocation[i, 1]:&gt;7.0f}  {allocation[i, 2]:&gt;7.0f}  {allocation[i, 3]:&gt;7.0f}\")\n\n    # Verification of resource usage\n    supply_used = np.sum(allocation, axis=1)\n    print(\"\\nResource Utilization:\")\n    for i in range(num_plants):\n        print(f\"  - Plant {i+1} Used: {supply_used[i]:.0f} / {supply_capacity[i]} MWh\")\n    \n    total_supply_used = np.sum(supply_used)\n    total_demand_met = np.sum(demand_req)\n    print(f\"  - Total Power Generated: {total_supply_used:.0f} MWh\")\n    print(f\"  - Total Power Demanded:  {total_demand_met:.0f} MWh\")\n    print(f\"  - Unused Capacity:       {np.sum(supply_capacity) - total_supply_used:.0f} MWh\")\n\nelse:\n    print(\"Optimization failed.\")\n    print(f\"Message: {result.message}\")\n\n\n\n\n\nOptimal Power Distribution Plan Found!\n\nMinimum Total Transmission Cost = $11,500.00\n\nOptimal Allocation Matrix (in MWh):\n           City A   City B   City C   City D\n-----------------------------------------------\nPlant 1 |     250        0        0        0\nPlant 2 |       0      300      200        0\nPlant 3 |       0        0      200      200\n\nResource Utilization:\n  - Plant 1 Used: 250 / 350 MWh\n  - Plant 2 Used: 500 / 500 MWh\n  - Plant 3 Used: 400 / 400 MWh\n  - Total Power Generated: 1150 MWh\n  - Total Power Demanded:  1150 MWh\n  - Unused Capacity:       100 MWh\n\n\n\nFigure 6.5\n\n\n\n\n\n6.2.6.2 Results and Discussion\n\nOptimal Solution: The optimal power distribution plan results in a minimum total transmission cost of $11,500. The specific power flows are detailed in the allocation matrix. The solver intelligently assigns generation to meet demand via the cheapest available routes. For example, Plant 2, having the lowest cost to City C ($8/MWh), supplies all 500 MWh of that city’s demand. Similarly, Plant 3, with the best rate to City D ($10/MWh), covers all of its 400 MWh demand. The needs of the more expensive-to-reach cities (A and B) are met by the remaining capacity from the most cost-effective plants.\nHandling Unbalanced Problems: The key to this problem was correctly formulating the constraints. The supply constraints were set as inequalities (&lt;=), allowing plants to generate less than their maximum capacity. Conversely, the demand constraints were set as equalities (=), forcing the system to satisfy the needs of every city. The LP solver handled this mixed-constraint system perfectly, automatically creating a “slack” in the supply where it was most economical.\nResource Utilization and Strategic Insights: The solution reveals that the total power generated is 1150 MWh, exactly matching the total demand. This leaves an unused generation capacity of 100 MWh in the system. The utilization breakdown clearly shows this slack capacity is entirely at Plant 1, which only generates 250 MWh out of its 350 MWh maximum.\n\nStrategic Implication: This result provides a powerful insight for the energy company: Plant 1 is their most “expensive” or least strategically located plant relative to the current demand centers. For long-term planning, they might consider de-commissioning or reducing the maintenance budget for Plant 1. Alternatively, they could use this model to incentivize new, energy-intensive industries to build facilities near Plant 1, offering them lower transmission costs and taking advantage of the surplus capacity.\n\nEngineering Significance: This application demonstrates how optimization is critical in the design and operation of large-scale infrastructure like power grids. By using linear programming, grid operators can perform “economic dispatch,” deciding in near real-time which power plants should ramp up or down to meet fluctuating demand at the lowest possible cost. This ensures both the stability of the grid and its economic efficiency, a core task in power systems engineering.",
    "crumbs": [
      "Optimization",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lab Session 5: Optimization Methods in Engineering</span>"
    ]
  }
]