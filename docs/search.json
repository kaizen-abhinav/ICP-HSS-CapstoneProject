[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "24BSE2113D-Computational Methods for Electronics & Robotics Lab",
    "section": "",
    "text": "1 Welcome to the Computational Methods Lab\nThis interactive lab manual is designed for third-semester B.Tech students in Electronics and Robotics. The goal of this course is to introduce powerful computational techniques for solving common engineering problems using the Python programming language.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome to the Computational Methods Lab</span>"
    ]
  },
  {
    "objectID": "index.html#why-python",
    "href": "index.html#why-python",
    "title": "24BSE2113D-Computational Methods for Electronics & Robotics Lab",
    "section": "1.1 Why Python?",
    "text": "1.1 Why Python?\nWhile MATLAB is a traditional tool in engineering, Python has become the industry standard in modern robotics, machine learning, and data science. By learning Python, you are acquiring a versatile skill that is highly sought after in today’s tech landscape. It’s free, open-source, and has a vast ecosystem of libraries that we will leverage throughout this course.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome to the Computational Methods Lab</span>"
    ]
  },
  {
    "objectID": "index.html#software-setup",
    "href": "index.html#software-setup",
    "title": "24BSE2113D-Computational Methods for Electronics & Robotics Lab",
    "section": "1.2 Software Setup",
    "text": "1.2 Software Setup\nBefore you begin, please ensure you have the following installed on your system. We highly recommend installing the Anaconda Distribution, which packages Python and all the necessary libraries together.\n\nPython 3.8+\nNumPy: For numerical operations.\nMatplotlib: For plotting and visualization.\nSymPy: For symbolic mathematics (algebra and calculus).\nSciPy: For scientific computing, including optimization.\n\nYou can run the code in this book interactively by using a Jupyter Notebook or an IDE like Spyder or VS Code with Python extensions.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome to the Computational Methods Lab</span>"
    ]
  },
  {
    "objectID": "01-intro-python.html",
    "href": "01-intro-python.html",
    "title": "2  Lab Session 1: Python’s Scientific Stack",
    "section": "",
    "text": "2.1 Excercise 1: The Core Trio - NumPy, Matplotlib, and SymPy\nThis session introduces the fundamental libraries that make Python a powerhouse for engineering.\nObjective: To get comfortable creating arrays, plotting data, and performing symbolic calculations.",
    "crumbs": [
      "Fundamentals",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Lab Session 1: Python's Scientific Stack</span>"
    ]
  },
  {
    "objectID": "01-intro-python.html#excercise-1-the-core-trio---numpy-matplotlib-and-sympy",
    "href": "01-intro-python.html#excercise-1-the-core-trio---numpy-matplotlib-and-sympy",
    "title": "2  Lab Session 1: Python’s Scientific Stack",
    "section": "",
    "text": "2.1.1 Pyton basics- Recap\n\n2.1.1.1 Hello World\nThe classic first program for any language.\n\n\nCode\nprint(\"Hello, B.Tech Students!\")\n\n\nHello, B.Tech Students!\n\n\n\n\n2.1.1.2 Variables and Data Types\nIntroduction to different data types like integers, floats, and strings.\n\n\nCode\nx = 10  # Integer\ny = 3.5  # Float\nname = \"Python\"  # String\nis_student = True  # Boolean\n\nprint(x, y, name, is_student)\n\n\n10 3.5 Python True\n\n\n\n\n2.1.1.3 Conditional Statements\nUsing if, elif, and else statements.\n\n\nCode\nx = 10  # Integer\ny = 3.5  # Float\nname = \"Python\"  # String\nis_student = True  # Boolean\n\nprint(x, y, name, is_student)\n\n\n10 3.5 Python True\n\n\n\n\n2.1.1.4 Loops/ Iteratives\nUsing for and while loops.\n\n\nCode\n# For loop\nfor i in range(5):\n    print(\"Iteration:\", i)\n\n\nIteration: 0\nIteration: 1\nIteration: 2\nIteration: 3\nIteration: 4\n\n\n\n\nCode\n# While loop\nn = 0\nwhile n &lt; 3:\n    print(\"While loop iteration:\", n)\n    n += 1\n\n\nWhile loop iteration: 0\nWhile loop iteration: 1\nWhile loop iteration: 2\n\n\n\n\n2.1.1.5 Functions\nDefining and calling functions.\n\n\nCode\ndef add_numbers(a, b):\n    return a + b\n\nresult = add_numbers(5, 3)\nprint(\"Sum:\", result)\n\n\nSum: 8\n\n\n\n\n2.1.1.6 Basic Numerical Computations using NumPy\nNumPy is useful for numerical operations.\n\n\nCode\n#Solve 2x+3y=54x+4y=6\nimport numpy as np\n\nA = np.array([[2, 3], [4, 4]])\nb = np.array([5, 6])\n\nx = np.linalg.solve(A, b)\nprint(\"Solution:\", x)\n\n\nSolution: [-0.5  2. ]\n\n\n\n\n2.1.1.7 Plotting Graphs with Matplotlib\nMatplotlib is used for simple visualizations. Install using: pip install matplotlib\n\n\nCode\n#Plotting a sine wave \nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0, 10, 100)\ny = np.sin(x)\n\nplt.plot(x, y)\nplt.xlabel(\"x\")\nplt.ylabel(\"sin(x)\")\nplt.title(\"Sine Wave\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Parameters\nVs = 5.0  # Source voltage (Volts)\nR = 1000  # Resistance (Ohms)\nC = 1e-6  # Capacitance (Farads)\ntau = R * C # Time constant\n\n# Create a time vector from 0 to 5*tau\nt = np.linspace(0, 5 * tau, 100)\n\n# Calculate voltage using the formula\nVc = Vs * (1 - np.exp(-t / tau))\n\n# Plotting the result\nplt.figure(figsize=(8, 5))\nplt.plot(t, Vc, label=f'RC = {tau}s')\nplt.title('Capacitor Charging Voltage')\nplt.xlabel('Time (s)')\nplt.ylabel('Voltage (V)')\nplt.grid(True)\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2.1: Voltage across a charging capacitor in an RC circuit.\n\n\n\n\n\n\n\n2.1.1.8 Solution of PDE Using SciPy\nSciPy provides numerical solvers for differential equations and optimizations.\n\n\n\n\n\n\nInstalling Scipy\n\n\n\nThe Scipy library can be installed using the pip install scipy command in terminal or using !pip install scipy in colab.\n\n\n\n\nCode\n#Solving a Simple PDE ∂u/∂x + ∂u/∂t=0\nfrom sympy import symbols, Function, Eq, Derivative, pdsolve\n\n# Define variables\nx, t = symbols('x t')\nu = Function('u')(x, t)\n\n# Define a simple PDE: ∂u/∂x + ∂u/∂t = 0\npde = Eq(Derivative(u, x) + Derivative(u, t), 0)\n\n# Solve the PDE using pdsolve\nsolution = pdsolve(pde)\n# Print the solution\nprint(solution)\n\n\nEq(u(x, t), F(-t + x))\n\n\n\n\nCode\n# Example: Solving an ODE as an approximation for a PDE\nfrom scipy.integrate import solve_ivp\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef pde_rhs(t, u):\n    return -0.5 * u  # Example equation\n\nsol = solve_ivp(pde_rhs, [0, 10], [1], t_eval=np.linspace(0, 10, 100))\nplt.plot(sol.t, sol.y[0])\nplt.xlabel('Time')\nplt.ylabel('Solution')\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2.2: Solution of PDE.\n\n\n\n\n\n\n\n2.1.1.9 Basic Optimization Using SymPy\nSymPy is a symbolic mathematics library that can be used to derive analytical solutions to PDEs.\n\n\nCode\nfrom scipy.optimize import minimize\n\ndef objective(x):\n    return x**2 + 2*x + 1\n\nresult = minimize(objective, 0)  # Start search at x=0\nprint(\"Optimal x:\", result.x)\n\n\nOptimal x: [-1.00000001]",
    "crumbs": [
      "Fundamentals",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Lab Session 1: Python's Scientific Stack</span>"
    ]
  },
  {
    "objectID": "01-intro-python.html#practice-tasks",
    "href": "01-intro-python.html#practice-tasks",
    "title": "2  Lab Session 1: Python’s Scientific Stack",
    "section": "2.2 Practice tasks",
    "text": "2.2 Practice tasks\n\n2.2.1 T-1: Representing an Analog Signal\nConcept: In electronics, continuous analog signals (like AC voltage) are sampled at discrete time intervals to be processed by a digital system (like a microcontroller or computer). A NumPy array is the perfect way to store these sampled values.\nPython Skills: * np.linspace(): To create an array of evenly spaced time points. * np.sin(): An element-wise function that applies the sine function to every value in an array.\nTask: Generate and plot a 50 Hz sine wave voltage signal with a peak voltage of 5V, sampled for 3 cycles.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- Parameters ---\nfrequency = 50  # Hz\npeak_voltage = 5.0  # Volts\ncycles = 3\nsampling_rate = 1000 # Samples per second\n\n# --- Time Array Generation ---\n# Duration of 3 cycles is 3 * (1/frequency)\nduration = cycles / frequency \n# Create 1000 points per second * duration\nnum_samples = int(sampling_rate * duration)\nt = np.linspace(0, duration, num_samples)\n\n# --- Signal Generation ---\n# The formula for a sine wave is V(t) = V_peak * sin(2 * pi * f * t)\nvoltage = peak_voltage * np.sin(2 * np.pi * frequency * t)\n\n# --- Visualization ---\nplt.figure(figsize=(10, 4))\nplt.plot(t, voltage)\nplt.title('Digital Representation of a 50 Hz Sine Wave')\nplt.xlabel('Time (s)')\nplt.ylabel('Voltage (V)')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2.3: A 5V, 50 Hz sine wave sampled over time.\n\n\n\n\n\n\n\n2.2.2 T-2: Modeling a Noisy Sensor Reading\nConcept: Real-world sensor data is never perfect. It’s often corrupted by random noise. We can simulate this by adding a random component to our ideal signal.\nPython Skills: - Array Addition: Simply using + to add two arrays of the same shape.\n\nnp.random.normal(): To generate Gaussian noise, which is a common model for electronic noise.\n\nTask: Take the 5V sine wave from the previous example and add Gaussian noise with a standard deviation of 0.5V to simulate a noisy sensor reading.\n\n\nCode\n# We can reuse the 't' and 'voltage' arrays from the previous example\nnoise_amplitude = 0.5 # Standard deviation of the noise in Volts\n\n# Generate noise with the same shape as our voltage array\nnoise = np.random.normal(0, noise_amplitude, voltage.shape)\n\n# Create the noisy signal by adding the noise to the ideal signal\nnoisy_voltage = voltage + noise\n\n# --- Visualization ---\nplt.figure(figsize=(10, 4))\nplt.plot(t, voltage, label='Ideal Signal', linestyle='--')\nplt.plot(t, noisy_voltage, label='Noisy Sensor Reading', alpha=0.75)\nplt.title('Ideal vs. Noisy Signal')\nplt.xlabel('Time (s)')\nplt.ylabel('Voltage (V)')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2.4: Ideal sine wave vs. a simulated noisy sensor reading.\n\n\n\n\n\n\n\n2.2.3 T-3: Forward Kinematics of a 2-Link Robot Arm\nConcept: Forward kinematics in robotics is the process of calculating the position of the robot’s end-effector (e.g., its gripper) based on its joint angles. For a simple 2D arm, this involves basic trigonometry.\nPython Skills:\n\nUsing arrays to represent vectors (link lengths).\nUsing scalar variables for parameters (joint angles).\nBasic arithmetic and trigonometric functions (np.cos, np.sin, np.deg2rad).\n\nTask: Calculate and plot the position of a 2-link planar robot arm with link lengths L1=1.0m and L2=0.7m for given joint angles theta1=30° and theta2=45°.\n\n\nCode\n# --- Parameters ---\nL1 = 1.0  # Length of link 1\nL2 = 0.7  # Length of link 2\ntheta1_deg = 30\ntheta2_deg = 45\n\n# Convert angles to radians for numpy's trig functions\ntheta1 = np.deg2rad(theta1_deg)\ntheta2 = np.deg2rad(theta2_deg)\n\n# --- Kinematics Calculations ---\n# Position of the first joint (end of L1)\nx1 = L1 * np.cos(theta1)\ny1 = L1 * np.sin(theta1)\n\n# Position of the end-effector (end of L2) relative to the first joint\n# The angle of the second link is theta1 + theta2\nx2 = x1 + L2 * np.cos(theta1 + theta2)\ny2 = y1 + L2 * np.sin(theta1 + theta2)\n\n# --- Visualization ---\nplt.figure(figsize=(6, 6))\n# Plot the arm links\nplt.plot([0, x1], [0, y1], 'r-o', linewidth=3, markersize=10, label='Link 1')\nplt.plot([x1, x2], [y1, y2], 'b-o', linewidth=3, markersize=10, label='Link 2')\n\n# Plot the base and end-effector positions for clarity\nplt.plot(0, 0, 'ko', markersize=15, label='Base')\nplt.plot(x2, y2, 'gX', markersize=15, label='End-Effector')\n\nplt.title('2-Link Robot Arm Kinematics')\nplt.xlabel('X Position (m)')\nplt.ylabel('Y Position (m)')\nplt.grid(True)\nplt.axis('equal') # Important for correct aspect ratio\nplt.legend()\nplt.show()\n\nprint(f\"End-effector is at position: ({x2:.2f}, {y2:.2f})\")\n\n\n\n\n\n\n\n\nFigure 2.5: Position of a 2-link robot arm using forward kinematics.\n\n\n\n\n\nEnd-effector is at position: (1.05, 1.18)\n\n\n\n\n2.2.4 T-4: Rotating a Sensor’s Coordinate Frame\nConcept: A robot often has sensors (like a camera or a Lidar) mounted at an angle. To understand the sensor data in the robot’s own coordinate frame, we need to rotate the data points. This is a fundamental operation in robotics and computer vision, done using a rotation matrix.\nPython Skills:\n\nCreating a 2D NumPy array (a matrix).\nMatrix multiplication using the @operator.\nTransposing an array (.T) for correct multiplication dimensions.\n\nTask: A sensor detects an object at coordinates (2, 0) in its own frame. The sensor is rotated 45 degrees counter-clockwise relative to the robot’s base. Find the object’s coordinates in the robot’s frame.\n\n\nCode\n# Angle of the sensor relative to the robot\nangle_deg = 45\nangle_rad = np.deg2rad(angle_deg)\n\n# Point detected in the sensor's frame [x, y]\np_sensor = np.array([[2], [0]]) # As a column vector\n\n# 2D Rotation Matrix\n# R = [[cos(theta), -sin(theta)],\n#      [sin(theta),  cos(theta)]]\nR = np.array([[np.cos(angle_rad), -np.sin(angle_rad)],\n              [np.sin(angle_rad),  np.cos(angle_rad)]])\n\n# The transformation: p_robot = R @ p_sensor\np_robot = R @ p_sensor\n\n# --- Visualization ---\nplt.figure(figsize=(6, 6))\n# Plot sensor's axes\nplt.quiver(0, 0, np.cos(angle_rad), np.sin(angle_rad), color='r', scale=3, label=\"Sensor x'-axis\")\nplt.quiver(0, 0, -np.sin(angle_rad), np.cos(angle_rad), color='g', scale=3, label=\"Sensor y'-axis\")\n\n# Plot the point in the robot's frame\nplt.plot(p_robot[0], p_robot[1], 'bo', markersize=10, label='Point in Robot Frame')\n# For context, let's show where the point was in the sensor's frame (if it weren't rotated)\n# This is just for visualization\nplt.plot(p_sensor[0], p_sensor[1], 'ko', markersize=10, alpha=0.5, label='Original point (relative to axes)')\n\n\nplt.axhline(0, color='black', linewidth=0.5)\nplt.axvline(0, color='black', linewidth=0.5)\nplt.grid(True)\nplt.axis('equal')\nplt.xlim(-1, 3)\nplt.ylim(-1, 3)\nplt.title(\"Coordinate Frame Rotation\")\nplt.xlabel(\"Robot X-axis\")\nplt.ylabel(\"Robot Y-axis\")\nplt.legend()\nplt.show()\n\nprint(\"Rotation Matrix:\\n\", np.round(R, 2))\nprint(f\"\\nPoint in Sensor Frame: {p_sensor.flatten()}\")\nprint(f\"Point in Robot Frame:  {np.round(p_robot.flatten(), 2)}\")\n\n\n\n\n\n\n\n\nFigure 2.6: Rotating a point from a sensor’s frame to the robot’s frame.\n\n\n\n\n\nRotation Matrix:\n [[ 0.71 -0.71]\n [ 0.71  0.71]]\n\nPoint in Sensor Frame: [2 0]\nPoint in Robot Frame:  [1.41 1.41]\n\n\n\n\n2.2.5 T-5: Applying a Simple Digital Filter\nConcept: To clean up the noisy signal from Example 3, we can apply a digital filter. The simplest is a moving average filter, which replaces each data point with the average of itself and its neighbors. This smooths out sharp fluctuations (noise).\nPython Skills:\n\nLooping over an array.\nArray slicing: array[start:end].\nnp.mean(): To calculate the average of a set of numbers.\n\nTask: Apply a 5-point moving average filter to the noisy_voltage signal created in Example 3 and plot the result to see the smoothing effect.\n\n\nCode\n# Let's regenerate the noisy signal for a self-contained example\n# (In a real notebook, you would reuse the variable from before)\nfrequency = 50\npeak_voltage = 5.0\nduration = 3 / frequency\nt = np.linspace(0, duration, int(1000 * duration))\nvoltage = peak_voltage * np.sin(2 * np.pi * frequency * t)\nnoise = np.random.normal(0, 0.5, voltage.shape)\nnoisy_voltage = voltage + noise\n\n# --- Filtering ---\nwindow_size = 5\n# Create an empty array to store the filtered signal\nfiltered_voltage = np.zeros_like(noisy_voltage)\n\n# Loop through the signal. We can't compute a full window at the very edges,\n# so we'll just copy the original values for the first and last few points.\nfor i in range(len(noisy_voltage)):\n    # Find the start and end of the slice\n    start = max(0, i - window_size // 2)\n    end = min(len(noisy_voltage), i + window_size // 2 + 1)\n    \n    # Get the window of data and calculate its mean\n    window = noisy_voltage[start:end]\n    filtered_voltage[i] = np.mean(window)\n\n# --- Visualization ---\nplt.figure(figsize=(10, 4))\nplt.plot(t, noisy_voltage, label='Noisy Signal', alpha=0.5)\nplt.plot(t, filtered_voltage, label='Filtered Signal', color='r', linewidth=2)\nplt.title('Effect of Moving Average Filter')\nplt.xlabel('Time (s)')\nplt.ylabel('Voltage (V)')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2.7: Noisy signal smoothed using a 5-point moving average filter.",
    "crumbs": [
      "Fundamentals",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Lab Session 1: Python's Scientific Stack</span>"
    ]
  },
  {
    "objectID": "02-pde-numerical.html",
    "href": "02-pde-numerical.html",
    "title": "3  Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)",
    "section": "",
    "text": "3.1 Experiment 2: 1D Wave Equation (The Advection Equation)\nWhile Experiment 1 dealt with basic python programming and solution of a parabolic PDE (diffusion), this experiment focuses on a hyperbolic PDE, which describes phenomena that propagate, like waves. We will solve the 1D Linear Advection Equation, a fundamental model for wave motion.\nGoverning Equation: \\[ \\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = 0 \\]\nHere, u(x, t) is the quantity that is moving (e.g., the height of a water wave or the stress in a rod), x is position, t is time, and c is the constant speed at which the wave travels.",
    "crumbs": [
      "Partial Differential Equations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)</span>"
    ]
  },
  {
    "objectID": "02-pde-numerical.html#experiment-2-1d-wave-equation-the-advection-equation",
    "href": "02-pde-numerical.html#experiment-2-1d-wave-equation-the-advection-equation",
    "title": "3  Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)",
    "section": "",
    "text": "3.1.1 Aim\nTo solve the one-dimensional wave equation using the Upwind Method and compare the numerical result with the initial condition.\n\n\n3.1.2 Objectives\n\nTo learn how to solve partial differential equations using numerical methods.\nTo understand and apply the Finite Difference Method for hyperbolic equations.\nTo observe how a wave profile moves with time.\nTo write and run a Python program for the simulation.\n\n\n\n3.1.3 The Upwind Method Algorithm\nThe “upwind” name comes from the fact that for a wave moving to the right (c &gt; 0), we use information from the “upwind” direction (the left side, i-1) to determine the state at the next time step.\n\nDiscretize Domain: Set the number of space points (nx) and time steps (nt). Define the domain length (Lx) and total time (T). Calculate the step sizes \\(dx = \\dfrac{Lx}{(nx - 1)}\\) and \\(dt = \\dfrac{T}{nt}\\).\nCheck Stability (CFL Condition): Compute the Courant-Friedrichs-Lewy (CFL) number, \\(\\lambda = c \\frac{\\Delta t}{\\Delta x}\\). For the explicit upwind scheme to be stable, we must have \\(\\lambda \\le 1\\). This means the numerical wave speed (dx/dt) must be faster than the physical wave speed (c), so the calculation can “keep up” with the phenomenon.\nSet Initial Condition: Define the initial shape of the wave, u(x, 0).\nTime Marching Loop: For each time step n, iterate through all spatial points i and apply the upwind formula to find the wave’s new state u_new. The discretized formula is: \\[ u_i^{n+1} = u_i^n - \\lambda (u_i^n - u_{i-1}^n) \\]\nUpdate: Set u = u_new.\nVisualize: Plot the final wave profile against the initial one.\n\n\n\n3.1.4 Case Study: Exponential Decay Wave\nLet’s simulate the equation \\(\\frac{\\partial u}{\\partial t} + \\frac{\\partial u}{\\partial x} = 0\\) (so c=1) with the initial condition \\(u(x, 0) = e^{-x}\\).\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- 1. Discretize Domain ---\nnx = 50       # Number of spatial points\nnt = 30       # Number of time steps\nLx = 5.0      # Domain length\nT = 2.0       # Total time\ndx = Lx / (nx - 1)  # Spatial step\ndt = T / nt         # Time step\n\nc = 1.0       # Wave speed\n\n# --- 2. Check Stability ---\nlambda_ = c * dt / dx\nprint(f\"CFL Number (lambda) = {lambda_:.4f}\")\nif lambda_ &gt; 1:\n    print(\"Warning: CFL condition not met. The solution may be unstable!\")\n\n# --- 3. Set Initial Condition ---\nx = np.linspace(0, Lx, nx)\nu = np.exp(-x)  # u(x, 0) = e^(-x)\nu_initial = u.copy() # Save the initial state for plotting\n\n# --- 4. & 5. Time Marching Loop ---\nfor n in range(nt):\n    u_old = u.copy()\n    # Apply upwind formula to all interior points\n    for i in range(1, nx):\n        u[i] = u_old[i] - lambda_ * (u_old[i] - u_old[i-1])\n\n# --- 6. Visualize ---\nplt.figure(figsize=(10, 6))\nplt.plot(x, u_initial, 'r--', label=\"Initial Condition at t=0\")\nplt.plot(x, u, 'b-', marker='o', markersize=4, label=f\"Numerical Solution at t={T}\")\nplt.xlabel(\"Position (x)\")\nplt.ylabel(\"u(x, t)\")\nplt.legend()\nplt.title(\"Solution of 1D Advection Equation (Upwind Scheme)\")\nplt.grid(True)\nplt.show()\n\n\nCFL Number (lambda) = 0.6533\n\n\n\n\n\n\n\n\nFigure 3.1: Numerical solution of the advection equation with an exponential initial condition using the Upwind scheme.\n\n\n\n\n\n\n\n3.1.5 Result and Discussion\nThe numerical solution using the Upwind Method for the initial condition \\(u(x,0)=e^{-x}\\) shows the wave propagating to the right, as expected. The Courant number \\(\\lambda=c\\dfrac{dt}{dx}\\) was maintained within the stability range (\\(\\lambda\\leq 1\\)), ensuring a stable and oscillation-free result. However, we can observe two key phenomena characteristic of this first-order scheme:\n\nNumerical Diffusion: The final wave shape is “smeared” or smoothed out compared to the initial condition. The sharp features are dampened. This is artificial damping introduced by the numerical method itself.\nAmplitude Decay: The peak of the wave seems to decrease slightly.\n\nDespite these inaccuracies, the upwind scheme is computationally simple and robust, making it effective for simulating basic convection phenomena where the general transport behavior is more important than preserving the exact shape of the wave.",
    "crumbs": [
      "Partial Differential Equations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)</span>"
    ]
  },
  {
    "objectID": "02-pde-numerical.html#application-problem-stress-wave-in-a-rod",
    "href": "02-pde-numerical.html#application-problem-stress-wave-in-a-rod",
    "title": "3  Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)",
    "section": "3.2 Application Problem: Stress Wave in a Rod",
    "text": "3.2 Application Problem: Stress Wave in a Rod\nIn mechanical systems, like long slender rods or beams, stress waves travel due to sudden loads or impacts. When a rod is struck at one end, a wave of stress and strain travels along its length. This can be modeled using the same 1D advection equation.\nTask: Modify the code above to simulate a “square pulse” stress wave.\nGoverning Equation: \\(\\frac{\\partial u}{\\partial t}+c\\frac{\\partial u}{\\partial t}=0\\).\nInitial Condition: A square pulse representing a localized impact.\n\\[u(x,0)=\\begin{cases} 1&; 0.4\\leq x\\leq 0.6\\\\ 0&; \\text{otherwise}\\end{cases}\\]\nYour Challenge:\n\nCopy the Python code block from the previous example.\nChange the line that sets the initial condition u to create the square pulse described above. Hint: You can use NumPy’s logical indexing. For example: u[ (x &gt;= 0.4) & (x &lt;= 0.6) ] = 1.0. You will need to initialize u as an array of zeros first: u = np.zeros(nx).\nRe-run the simulation. Observe how the sharp corners of the square wave are smoothed out due to numerical diffusion.\n\n\n3.2.0.1 Solution to the Application Problem: Stress Wave in a Rod\nHere, we apply the same Upwind Method to the practical problem of a stress wave propagating through a mechanical rod. The initial condition is a square pulse, which could represent a short, sharp impact from a hammer strike on a specific section of the rod.\n\nPython Implementation\n\nThe core algorithm remains the same. The only change is in how we define the initial condition u(x, 0).\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- 1. Discretize Domain (same as before) ---\nnx = 101      # Increased points for better resolution\nnt = 50       # Increased time steps\nLx = 2.0      # Longer domain to see the wave travel\nT = 1.0       # Total time\ndx = Lx / (nx - 1)\ndt = T / nt\nc = 1.0       # Wave speed\n\n# --- 2. Check Stability ---\nlambda_ = c * dt / dx\nprint(f\"CFL Number (lambda) = {lambda_:.4f}\")\nif lambda_ &gt; 1:\n    print(\"Warning: CFL condition not met. The solution may be unstable!\")\n\n# --- 3. Set Initial Condition: Square Pulse ---\nx = np.linspace(0, Lx, nx)\n# Initialize u as an array of zeros\nu = np.zeros(nx)\n# Set the pulse region to 1.0 using logical indexing\nu[(x &gt;= 0.4) & (x &lt;= 0.6)] = 1.0\n\n# Save the initial state for plotting\nu_initial = u.copy()\n\n# --- 4. & 5. Time Marching Loop (same as before) ---\nfor n in range(nt):\n    u_old = u.copy()\n    for i in range(1, nx):\n        u[i] = u_old[i] - lambda_ * (u_old[i] - u_old[i-1])\n\n# --- 6. Visualize ---\n# Calculate the analytical solution's position for comparison\n# The pulse should have moved by a distance of c*T\nanalytical_x_start = 0.4 + c * T\nanalytical_x_end = 0.6 + c * T\n\nplt.figure(figsize=(10, 6))\nplt.plot(x, u_initial, 'r--', label=\"Initial Condition (t=0)\")\nplt.plot(x, u, 'b-', marker='.', markersize=5, label=f\"Numerical Solution (t={T})\")\n\n# Plot the theoretical \"perfect\" wave for comparison\nplt.plot([analytical_x_start, analytical_x_end], [1, 1], 'g:', linewidth=3, label=f'Analytical Position (t={T})')\nplt.plot([analytical_x_start, analytical_x_start], [0, 1], 'g:', linewidth=3)\nplt.plot([analytical_x_end, analytical_x_end], [0, 1], 'g:', linewidth=3)\n\n\nplt.xlabel(\"Position along rod (x)\")\nplt.ylabel(\"Stress/Strain (u)\")\nplt.ylim(-0.2, 1.2) # Set y-axis limits for better visualization\nplt.legend()\nplt.title(\"Simulation of a Square Stress Wave\")\nplt.grid(True)\nplt.show()\n\n\nCFL Number (lambda) = 1.0000\n\n\n\n\n\n\n\n\nFigure 3.2: Propagation of a square pulse stress wave, showing significant numerical diffusion.\n\n\n\n\n\n\n\n3.2.0.2 Discussion of the Square Pulse Result\nWave Propagation: The primary success of the simulation is clearly visible: the pulse has moved to the right. The leading edge of the numerical solution is centered around the correct analytical position (x = 1.4 for the start of the pulse), confirming that the model correctly captures the fundamental advection behavior at speed c=1 over time T=1.\nNumerical Diffusion: The most striking feature of the result is the severe smoothing of the square pulse. The sharp, vertical edges of the initial condition have been transformed into gentle slopes. The flat top of the pulse has become rounded and its peak amplitude has decreased from 1.0 to approximately 0.75. This is a classic and pronounced example of numerical diffusion, an error inherent in the first-order upwind scheme. The scheme struggles to resolve sharp gradients (discontinuities), so it effectively “smears” them out over several grid points.\nPractical Implications: In a real engineering scenario, if we needed to know the exact peak stress and its precise location, this simple method would be inadequate. The predicted peak stress is significantly lower than the actual initial stress, which could lead to an incorrect safety assessment.\nImproving the Model: While the upwind scheme is simple, its diffusive nature is a major drawback for problems requiring high accuracy. To improve the result and preserve the sharpness of the wave, engineers would use:\n\nHigher-Order Schemes: Methods like the Lax-Wendroff scheme or flux-limiter methods are designed to be less diffusive and capture sharp fronts more accurately.\nFiner Grid: Reducing dx and dt (while keeping lambda stable) can decrease the amount of diffusion, but at a significant computational cost.\n\n\n\n3.2.0.3 Result\nThe application simulation successfully models the physical propagation of a stress wave. However, it also serves as a crucial lesson in computational engineering: every numerical method has inherent errors and limitations. The Upwind Method, while stable and simple, introduces significant numerical diffusion that must be considered when interpreting the results.",
    "crumbs": [
      "Partial Differential Equations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)</span>"
    ]
  },
  {
    "objectID": "02-pde-numerical.html#experiment-3-solving-the-1d-heat-equation",
    "href": "02-pde-numerical.html#experiment-3-solving-the-1d-heat-equation",
    "title": "3  Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)",
    "section": "3.3 Experiment 3: Solving the 1D Heat Equation",
    "text": "3.3 Experiment 3: Solving the 1D Heat Equation\nThis experiment introduces the numerical solution of a parabolic partial differential equation: the one-dimensional heat equation. This equation is fundamental to understanding diffusion processes, not just in heat transfer but also in chemical concentration gradients and other physical phenomena.\n\n3.3.1 Aim\nTo solve the one-dimensional heat conduction equation using the Finite Difference Method (explicit scheme) in Python and to visualize the temperature distribution over time.\n\n\n3.3.2 Objectives\n\nTo understand the physical interpretation of the one-dimensional heat equation.\nTo discretize the heat equation using the Forward Time Centred Space (FTCS) scheme.\nTo implement the finite difference method in Python.\nTo analyze the stability condition required for this numerical method.\nTo visualize the temperature profiles at different time levels.\n\n\n\n3.3.3 Governing Equation and Discretization\nThe one-dimensional heat equation describes how temperature u evolves at a position x and time t. It is given by:\n\\[\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}\n\\]\nwhere \\(\\alpha\\) is the thermal diffusivity of the material, a constant that indicates how quickly the material conducts heat.\nTo solve this numerically, we use the FTCS method. We approximate the derivatives with finite differences: * Time Derivative (Forward Difference): \\(\\frac{\\partial u}{\\partial t} \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}\\) * Space Derivative (Centred Difference): \\(\\frac{\\partial^2 u}{\\partial x^2} \\approx \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2}\\)\nHere, the superscript n denotes the time level and the subscript i denotes the spatial grid point. Substituting these into the governing equation and rearranging for the future temperature \\(u_i^{n+1}\\), we get the explicit update formula.\n\n\n3.3.4 Algorithm\n\nInitialize Parameters: Set the values for the rod length L, total simulation time T, number of spatial nodes \\(n_x\\), number of time steps \\(n_t\\), and thermal diffusivity \\(\\alpha\\).\nDiscretize the Domain: Calculate the step sizes for space and time.\n\nSpace step: \\(\\Delta x = \\frac{L}{n_x - 1}\\)\nTime step: \\(\\Delta t = \\frac{T}{n_t}\\)\n\nCheck Stability Condition: Calculate the stability parameter, r. For the FTCS scheme to be stable and produce a physically realistic result, this value must be less than or equal to 0.5. \\[\nr = \\frac{\\alpha \\Delta t}{(\\Delta x)^2} \\le 0.5\n\\]\nSet Initial and Boundary Conditions:\n\nDefine the initial temperature distribution along the rod, \\(u(x, 0)\\).\nApply boundary conditions. In this case, we use Dirichlet boundary conditions, which means the temperature at the ends of the rod is fixed for all time (e.g., \\(u(0, t) = u(L, t) = 0\\)).\n\nIterate Over Time: For each time step n, loop through all the interior spatial points i and update their temperature using the FTCS formula: \\[\nu_i^{n+1} = u_i^n + r \\left( u_{i+1}^n - 2u_i^n + u_{i-1}^n \\right)\n\\]\nOutput and Visualization: Store the temperature profiles at different time intervals and plot them to visualize the heat diffusion process.\n\n\n\n3.3.5 Sample Problem and Python Implementation\nProblem: Solve the 1D heat equation on a rod of length L=1.0 m with the following conditions: The temperature is zero everywhere except at the very center, where an initial “heat pulse” of 100°C is applied. The ends of the rod are kept at a constant 0°C for all time.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- 1. Initialize Parameters ---\nL = 1.0           # Length of the rod (meters)\nT = 0.1           # Total simulation time (seconds)\nnx = 21           # Number of spatial grid points (use an odd number for a perfect center)\nnt = 1000         # Number of time steps\nalpha = 0.01      # Thermal diffusivity (e.g., for copper)\n\n# --- 2. Discretize the Domain ---\ndx = L / (nx - 1)             # Space step size\ndt = T / nt                   # Time step size\n\n# --- 3. Check Stability Condition ---\nr = alpha * dt / dx**2\nprint(f\"Space step dx = {dx:.4f} m\")\nprint(f\"Time step dt = {dt:.4f} s\")\nprint(f\"Stability parameter r = {r:.4f}\")\nif r &gt; 0.5:\n    print(\"\\n--- WARNING: STABILITY CONDITION r &gt; 0.5 NOT MET! ---\")\n    print(\"The solution is likely to be unstable and blow up.\")\nelse:\n    print(\"\\nStability condition r &lt;= 0.5 is satisfied.\")\n\n\n# --- 4. Set Initial and Boundary Conditions ---\n# Spatial grid\nx = np.linspace(0, L, nx)\n\n# Initial condition: temperature distribution is zero everywhere...\nu = np.zeros(nx)\n# ...except for a pulse at the center.\nu[int((nx - 1) / 2)] = 100\n\n# Boundary conditions u(0,t)=0 and u(L,t)=0 are enforced by the loop range (1, nx-1)\n\n# --- 5. & 6. Time-stepping and Output ---\n# To store results at different time steps for plotting\nu_snapshots = [u.copy()]\nsnapshot_interval = 200 # Store a snapshot every 200 time steps\n\nfor n in range(nt):\n    u_old = u.copy()\n    # Loop over interior points to apply the FTCS formula\n    for i in range(1, nx - 1):\n        u[i] = u_old[i] + r * (u_old[i+1] - 2*u_old[i] + u_old[i-1])\n\n    # Store a snapshot of the solution at specified intervals\n    if (n + 1) % snapshot_interval == 0:\n        u_snapshots.append(u.copy())\n\n# --- Plotting the results ---\nplt.figure(figsize=(10, 6))\nfor i, u_snap in enumerate(u_snapshots):\n    time = i * snapshot_interval * dt\n    plt.plot(x, u_snap, label=f't = {time:.2f} s')\n\nplt.xlabel('Position along rod (x)')\nplt.ylabel('Temperature (°C)')\nplt.title('1D Heat Equation: Explicit FTCS Method')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\nSpace step dx = 0.0500 m\nTime step dt = 0.0001 s\nStability parameter r = 0.0004\n\nStability condition r &lt;= 0.5 is satisfied.\n\n\n\n\n\n\n\n\nFigure 3.3: Diffusion of a central heat pulse over time, calculated with the FTCS explicit method.",
    "crumbs": [
      "Partial Differential Equations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)</span>"
    ]
  },
  {
    "objectID": "02-pde-numerical.html#application-challenge-heat-dissipation-in-a-longer-rod",
    "href": "02-pde-numerical.html#application-challenge-heat-dissipation-in-a-longer-rod",
    "title": "3  Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)",
    "section": "3.4 Application Challenge: Heat Dissipation in a Longer Rod",
    "text": "3.4 Application Challenge: Heat Dissipation in a Longer Rod\nNow, let’s apply what you’ve learned to a new set of physical parameters. This exercise simulates heat dissipation in a longer structural beam with a more intense initial heat source.\n\nYour Task\n\nSimulate the 1D heat equation on a rod with the following new conditions:\n\nRod Length (L): 3.2 meters\nInitial Condition: The temperature is 0°C everywhere except for a single point at the very center, which has an intense initial temperature of 300°C.\nBoundary Conditions: The ends of the rod are maintained at 0°C (Dirichlet BC).\nMaterial: Assume the same thermal diffusivity, \\(\\alpha = 0.01\\).\nSimulation Time (T): Run the simulation for a longer time, T = 2.0 seconds, to observe more significant diffusion.\n\n\nThe Challenge\n\n\nCopy the Python code from the previous example.\nModify the parameter values (L, T, and the initial temperature pulse).\nCrucially, after changing L and T, you must re-calculate the stability parameter r. If r &gt; 0.5, the simulation will fail! You will need to adjust either nx (number of space points) or nt (number of time steps) to bring r back into the stable region (\\(\\le 0.5\\)). The goal is to find a stable combination.\n\n\nHint: The stability parameter is \\(r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}\\).\n\n\nIf your r value is too high, you have two options to decrease it:\nIncrease nt: This makes the time step Δt smaller, which is the most direct way to lower r.\nDecrease nx: This makes the space step Δx larger. While this also works, it reduces the spatial resolution of your simulation.\n\nTry increasing nt first. A good starting point would be to double it until r is stable.\n\nSolution to the Application Challenge\n\nHere is the complete Python code implementing the solution for the new parameters. The key is adjusting nt to ensure stability.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- 1. Initialize MODIFIED Parameters ---\nL = 3.2           # New Length of the rod (meters)\nT = 2.0           # New Total simulation time (seconds)\nnx = 51           # Number of spatial grid points (odd for a center)\n# nt must be adjusted for stability. Let's start with a high value.\nnt = 8000\nalpha = 0.01      # Thermal diffusivity\n\n# --- 2. Discretize the Domain ---\ndx = L / (nx - 1)\ndt = T / nt\n\n# --- 3. Check Stability Condition ---\nr = alpha * dt / dx**2\nprint(f\"--- Challenge Parameters ---\")\nprint(f\"Rod Length L = {L} m\")\nprint(f\"Space step dx = {dx:.4f} m\")\nprint(f\"Time step dt = {dt:.6f} s\")\nprint(f\"Stability parameter r = {r:.4f}\")\n\nif r &gt; 0.5:\n    required_nt = (alpha * T * (nx - 1)**2) / (0.5 * L**2)\n    print(f\"\\n--- WARNING: STABILITY FAILED (r &gt; 0.5) ---\")\n    print(f\"With nx={nx}, you need at least nt = {int(np.ceil(required_nt))} to achieve stability.\")\nelse:\n    print(\"\\nStability condition r &lt;= 0.5 is satisfied.\")\n\n\n# --- 4. Set Initial and Boundary Conditions ---\nx = np.linspace(0, L, nx)\nu = np.zeros(nx)\n# Set the new initial temperature pulse at the center\nu[int((nx - 1) / 2)] = 300.0\n\n# --- 5. & 6. Time-stepping and Output ---\nu_snapshots = [u.copy()]\nsnapshot_interval = nt // 4 # Store 4 snapshots over the total time\n\nfor n in range(nt):\n    u_old = u.copy()\n    for i in range(1, nx - 1):\n        u[i] = u_old[i] + r * (u_old[i] + u_old[i-1] - 2*u_old[i]) # Corrected formula\n\n    if (n + 1) % snapshot_interval == 0:\n        u_snapshots.append(u.copy())\n\n# --- Plotting the results ---\nplt.figure(figsize=(10, 6))\nfor i, u_snap in enumerate(u_snapshots):\n    time = i * snapshot_interval * dt\n    # The first plot is the initial condition at t=0\n    if i == 0:\n        time = 0.0\n    plt.plot(x, u_snap, label=f't = {time:.2f} s')\n\nplt.xlabel('Position along rod (x) [m]')\nplt.ylabel('Temperature (°C)')\nplt.title('Challenge: Heat Dissipation in a 3.2m Rod')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n--- Challenge Parameters ---\nRod Length L = 3.2 m\nSpace step dx = 0.0640 m\nTime step dt = 0.000250 s\nStability parameter r = 0.0006\n\nStability condition r &lt;= 0.5 is satisfied.\n\n\n\n\n\n\n\n\nFigure 3.4: Heat diffusion from a 300°C pulse in a 3.2m rod over 2.0 seconds.\n\n\n\n\n\n\n3.4.0.1 Results and Discussion of the Challenge\n\nStability Management: The primary challenge was maintaining stability. By increasing the rod length L significantly, the space step Δx became larger. Since Δx is squared in the denominator of the stability parameter r, this drastically increased the tendency for r to be large. To counteract this, the number of time steps nt had to be substantially increased (to 8000 in this solution) to make Δt small enough to keep r below the 0.5 threshold. This is a critical lesson in numerical methods: changing one parameter often necessitates adjusting others to maintain a valid simulation.\nSlower Diffusion: Comparing the plots to the first example, we can see that even though the simulation ran for a much longer time (2.0s vs 0.1s), the heat has not reached the ends of the rod. This is because the rod is much longer (3.2m vs 1.0m). Heat diffusion is a relatively slow process, and the increased distance means it takes significantly more time for the thermal energy to propagate.\nAmplitude and Profile: The initial peak temperature of 300°C drops very quickly, as the heat immediately begins to flow into the adjacent, colder sections of the rod. The resulting temperature profiles are wider and flatter compared to the first example at equivalent early stages, which is characteristic of diffusion over a larger domain.\n\nResult\nThe overall behavior remains physically consistent, demonstrating the robustness of the FTCS method when its stability condition is respected.",
    "crumbs": [
      "Partial Differential Equations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)</span>"
    ]
  },
  {
    "objectID": "02-pde-numerical.html#experiment-4-the-second-order-1d-wave-equation",
    "href": "02-pde-numerical.html#experiment-4-the-second-order-1d-wave-equation",
    "title": "3  Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)",
    "section": "3.5 Experiment 4: The Second-Order 1D Wave Equation",
    "text": "3.5 Experiment 4: The Second-Order 1D Wave Equation\nThis experiment moves from first-order to second-order hyperbolic PDEs by tackling the classic one-dimensional wave equation. This equation models a vast range of physical phenomena, including the vibrations of a guitar string, pressure waves in a tube, and the propagation of electromagnetic waves in a transmission line.\n\n3.5.1 Aim\nTo solve the one-dimensional wave equation using the finite difference method with an explicit time-stepping scheme.\n\n\n3.5.2 Objectives\n\nTo solve the second-order wave equation for a 1D domain with given initial and boundary conditions.\nTo implement the central difference scheme for both time and space derivatives.\nTo understand the role of initial displacement and initial velocity.\nTo simulate wave propagation and reflection and observe how waves evolve over time.\n\n\n\n3.5.3 Governing Equation and Discretization\nThe second-order, one-dimensional wave equation is given by: \\[\n\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\n\\] where \\(u(x,t)\\) is the displacement at position x and time t, and c is the constant wave propagation speed.\nTo solve this numerically, we use a central difference approximation for both derivatives: * Time Derivative: \\(\\frac{\\partial^2 u}{\\partial t^2} \\approx \\frac{u_i^{n+1} - 2u_i^n + u_i^{n-1}}{(\\Delta t)^2}\\) * Space Derivative: \\(\\frac{\\partial^2 u}{\\partial x^2} \\approx \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2}\\)\nSubstituting these into the governing equation and solving for the future displacement \\(u_i^{n+1}\\) gives the explicit update formula.\n\n\n3.5.4 Algorithm\n\nDiscretize the Domain:\n\nDivide the spatial domain of length L into discrete points using a step size \\(\\Delta x\\).\nDivide the time domain of total duration T using a time step \\(\\Delta t\\).\n\nStability Check (CFL Condition):\n\nCalculate the Courant Number, \\(C = \\frac{c \\Delta t}{\\Delta x}\\).\nFor this explicit scheme to be stable, the Courant number must satisfy \\(C \\le 1\\). If \\(C &gt; 1\\), the numerical solution will grow without bound and become meaningless.\n\nSet Initial Conditions:\n\nThis is a second-order equation in time, so we need two initial conditions:\n\nInitial displacement: \\(u(x, 0) = f(x)\\)\nInitial velocity: \\(\\frac{\\partial u}{\\partial t}(x, 0) = g(x)\\)\n\n\nSet Boundary Conditions:\n\nAssume the boundaries of the domain are fixed (e.g., the ends of a guitar string). This is a Dirichlet boundary condition: \\(u(0, t) = u(L, t) = 0\\) for all time t.\n\nTime-stepping Loop:\n\nThe update rule requires information from two previous time steps (n and n-1). This poses a problem for the very first step (n=1), as we don’t have a state at n=-1. We use a special formula for the first step derived from the initial velocity condition. For zero initial velocity, this simplifies.\nFor all subsequent time steps (n &gt; 1), use the main finite difference formula: \\[\nu_i^{n+1} = 2u_i^n - u_i^{n-1} + C^2 \\left( u_{i+1}^n - 2u_i^n + u_{i-1}^n \\right)\n\\]\n\nPlot and Visualize:\n\nAfter solving for all time steps, plot the wave’s displacement u(x) at different time instances to observe its motion and reflection.\n\n\n\n\n3.5.5 Application Problem and Python Implementation\nProblem: The vibration of a stretched string under tension is governed by the 1D wave equation. We are tasked with modeling the vibration of a string of length L=1.0m stretched between two fixed points. The string is given an initial displacement in the shape of a sine wave, \\(u(x,0) = \\sin(\\pi x)\\), but zero initial velocity.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- 1. Parameters & Discretization ---\nL = 1.0             # Length of the domain (string)\nc = 1.0             # Wave speed\ndx = 0.1            # Spatial step size\ndt = 0.05           # Time step size\nT = 2.0             # Total time (enough for one full reflection)\n\n# --- 2. Stability Check ---\nC = c * dt / dx\nprint(f\"Courant Number C = {C:.2f}\")\nif C &gt; 1:\n    raise ValueError(\"CFL condition (C &lt;= 1) not met. Instability expected.\")\nelse:\n    print(\"CFL condition is satisfied.\")\n\n# --- Grid setup ---\nx = np.arange(0, L + dx, dx)\nnx = len(x)\nnt = int(T / dt) + 1\n# Create a 2D array to store the solution at all time steps\nu = np.zeros((nt, nx))\n\n# --- 3. Initial Conditions ---\n# Initial displacement: u(x, 0) = sin(pi * x)\nu[0, :] = np.sin(np.pi * x)\n\n# Special formula for the first time step (n=1) assuming zero initial velocity\n# u_i^1 = u_i^0 + C^2/2 * (u_{i+1}^0 - 2u_i^0 + u_{i-1}^0)\nu[1, 1:-1] = u[0, 1:-1] + 0.5 * C**2 * (u[0, 2:] - 2*u[0, 1:-1] + u[0, :-2])\n# Boundary conditions u(0,t)=0 and u(L,t)=0 are already handled by slicing [1:-1]\n\n# --- 5. Time-stepping Loop ---\nfor n in range(1, nt - 1):\n    u[n + 1, 1:-1] = (2 * u[n, 1:-1] - u[n - 1, 1:-1] +\n                      C**2 * (u[n, 2:] - 2 * u[n, 1:-1] + u[n, :-2]))\n# Print results\nprint(\"x\\t\" + \"\\t\".join([f\"u^{n}\" for n in range(5)]))  # First 5 steps\nfor i in range(nx):\n    values = \"\\t\".join(f\"{u[n, i]:.4f}\" for n in range(5))\n    print(f\"{x[i]:.2f}\\t{values}\")\n# Optional: plot final wave\n# --- 6. Plot and Visualize ---\nplt.figure(figsize=(10, 6))\nplt.plot(x, u[0, :], 'r--', label='Initial (t=0)')\n# Time index for t = T/2\nmid_time_index = int(nt / 2)\nplt.plot(x, u[mid_time_index, :], 'g:', label=f'Mid-time (t={mid_time_index*dt:.2f}s)')\nplt.plot(x, u[-1, :], 'b-', label=f'Final (t={T:.2f}s)')\n\nplt.xlabel('Position along string (x)')\nplt.ylabel('Displacement (u)')\nplt.title('1D Wave Equation: Vibrating String Simulation')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\nCourant Number C = 0.50\nCFL condition is satisfied.\nx   u^0 u^1 u^2 u^3 u^4\n0.00    0.0000  0.0000  0.0000  0.0000  0.0000\n0.10    0.3090  0.3052  0.2940  0.2755  0.2504\n0.20    0.5878  0.5806  0.5592  0.5241  0.4762\n0.30    0.8090  0.7991  0.7697  0.7214  0.6554\n0.40    0.9511  0.9394  0.9048  0.8480  0.7705\n0.50    1.0000  0.9878  0.9514  0.8917  0.8102\n0.60    0.9511  0.9394  0.9048  0.8480  0.7705\n0.70    0.8090  0.7991  0.7697  0.7214  0.6554\n0.80    0.5878  0.5806  0.5592  0.5241  0.4762\n0.90    0.3090  0.3052  0.2940  0.2755  0.2504\n1.00    0.0000  0.0000  0.0000  0.0000  0.0000\n\n\n\n\n\n\n\n\nFigure 3.5: Vibration of a string with an initial sine-wave displacement, showing reflection.\n\n\n\n\n\n\n3.5.5.1 Result and Discussion\nThe simulation effectively models the behavior of a vibrating string with fixed ends.\n\nInitial State (t=0): The string starts in its initial sine wave shape, as defined.\nPropagation and Reflection: At the mid-time point (t=1.0s), the wave has traveled, reflected off the fixed boundaries, and become inverted. This is physically accurate: when a wave on a string hits a fixed end, it reflects back with opposite polarity.\nFinal State (t=2.0s): After one full period of oscillation, the wave has traveled to both ends, reflected, and returned to its original position and shape, demonstrating the periodic nature of the solution.\nStability: The CFL number was calculated as \\(C=0.5\\) , which satisfies the stability condition , \\(C\\leq 1\\). This ensures that the solution remains bounded and physically realistic.\nNumerical Dispersion: While not highly prominent in this example due to the smooth initial condition, some slight changes in the wave’s shape might be observed over longer simulation times. This is known as numerical dispersion, an artifact where different frequency components of the wave travel at slightly different speeds in the numerical grid.\n\nResult\nThe explicit finite difference method accurately captures the key dynamics of wave propagation and reflection, making it a powerful tool for analyzing such systems.",
    "crumbs": [
      "Partial Differential Equations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)</span>"
    ]
  },
  {
    "objectID": "02-pde-numerical.html#application-challenge-vibration-in-a-flexible-robot-link",
    "href": "02-pde-numerical.html#application-challenge-vibration-in-a-flexible-robot-link",
    "title": "3  Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)",
    "section": "3.6 Application Challenge: Vibration in a Flexible Robot Link",
    "text": "3.6 Application Challenge: Vibration in a Flexible Robot Link\nIn modern robotics, lightweight materials are used to create fast and efficient robots. However, these materials are often flexible. When a motor at the base of a robot link starts or stops suddenly, it can induce a longitudinal (compression/expansion) wave that travels down the link, causing vibrations at the end-effector (the robot’s tool or gripper). This vibration can severely impact the robot’s precision.\nWe can model this phenomenon using the 1D wave equation, where u(x,t) now represents the longitudinal displacement of the material from its resting position.\n\n\n\nSudden motor movement\n\n\n\n3.6.0.1 Your Task\nModel the vibration in a 2.0-meter long flexible robot link. * Physical Setup: * Base (x=0): Connected to a motor. We will model a sudden “jolt” by giving the base a brief, sharp displacement and then returning it to zero. * End-Effector (x=L): The end of the link is free to move. This is a Neumann boundary condition, which physically means the stress at the end is zero, or \\(\\frac{\\partial u}{\\partial x}(L, t) = 0\\). * Initial Conditions: The link is initially at rest. * Initial displacement \\(u(x,0) = 0\\). * Initial velocity \\(\\frac{\\partial u}{\\partial t}(x,0) = 0\\). * Wave Speed: The speed of sound (and thus stress waves) in this material is \\(c = 50\\) m/s.\n\n\n3.6.0.2 The Challenge\n\nImplement a New Boundary Condition: The motor’s jolt can be modeled by forcing the displacement at the base, u[n, 0], to be a short pulse. For example, a sine pulse for a very short duration at the beginning of the simulation.\nImplement the “Free End” (Neumann) Boundary: The condition \\(\\frac{\\partial u}{\\partial x}(L, t) = 0\\) can be approximated with a finite difference as \\(\\frac{u_{nx-1}^n - u_{nx-2}^n}{\\Delta x} = 0\\), which simplifies to \\(u_{nx-1}^n = u_{nx-2}^n\\). This means the last point always has the same displacement as the point next to it. You must enforce this at every time step.\nAnalyze the Result: Plot the displacement of the end-effector (u[:, -1]) over time to see how it vibrates in response to the motor’s jolt.\n\n\n\n3.6.0.3 Hints\n\nMotor Jolt: You can create the motor jolt inside the time-stepping loop. Use an if condition to apply the pulse only for a short time (e.g., when n*dt &lt; pulse_duration). A simple pulse could be u[n, 0] = A * np.sin(omega * n * dt).\nNeumann Boundary: After the main update loop for the interior points, add a line to enforce the free-end condition: u[n + 1, -1] = u[n + 1, -2]. The -1 index refers to the last element, and -2 refers to the second-to-last.\nStability: With a high wave speed (c=50), you will need a very small time step dt to satisfy the CFL condition (\\(C \\le 1\\)). Be prepared to use a large nt.\n\n\n\n3.6.1 Solution to the Robotics Application Challenge\nHere is the Python code that models the robot link vibration, incorporating the driving pulse at the base and the free-end boundary condition.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- 1. Parameters for the Robot Link ---\nL = 2.0             # Length of the robot link (m)\nc = 50.0            # Wave speed in the material (m/s)\nT = 0.15            # Total simulation time (s)\n\n# Discretization - fine grid needed for high wave speed\ndx = 0.04\n# dt must be chosen carefully for stability\ndt = dx / c * 0.9   # Choose dt based on dx and c to guarantee C=0.9\nC = c * dt / dx\n\nprint(f\"--- Robotics Challenge Parameters ---\")\nprint(f\"Wave Speed c = {c} m/s\")\nprint(f\"Courant Number C = {C:.2f}\")\nif C &gt; 1:\n    raise ValueError(\"CFL condition failed!\")\n\n# --- Grid setup ---\nx = np.arange(0, L + dx, dx)\nt_vec = np.arange(0, T + dt, dt)\nnx = len(x)\nnt = len(t_vec)\nu = np.zeros((nt, nx))\n\n# --- Motor Jolt Parameters ---\npulse_duration = 0.02  # s\npulse_amplitude = 0.001 # 1 mm jolt\npulse_frequency = 2 * np.pi / pulse_duration\n\n# --- 5. Time-stepping Loop with New Boundary Conditions ---\nfor n in range(1, nt - 1):\n    # Main update for interior points (from 2nd point to 2nd-to-last)\n    u[n + 1, 1:-1] = (2 * u[n, 1:-1] - u[n - 1, 1:-1] +\n                      C**2 * (u[n, 2:] - 2 * u[n, 1:-1] + u[n, :-2]))\n\n    # Boundary Condition 1: Motor Jolt at the Base (x=0)\n    current_time = n * dt\n    if current_time &lt; pulse_duration:\n        u[n + 1, 0] = pulse_amplitude * np.sin(pulse_frequency * current_time)\n    else:\n        u[n + 1, 0] = 0.0 # Motor holds firm at base after jolt\n\n    # Boundary Condition 2: Free End at x=L (Neumann)\n    # u_last = u_second_to_last\n    u[n + 1, -1] = u[n + 1, -2]\n\n# --- 6. Plot the End-Effector's Vibration ---\nend_effector_displacement = u[:, -1]\n\nplt.figure(figsize=(12, 6))\nplt.plot(t_vec, end_effector_displacement * 1000) # Convert to mm\nplt.title(\"Vibration of Robot End-Effector Over Time\")\nplt.xlabel(\"Time (s)\")\nplt.ylabel(\"Displacement (mm)\")\nplt.grid(True)\nplt.axhline(0, color='black', linewidth=0.5) # Zero line\nplt.show()\n\n\n--- Robotics Challenge Parameters ---\nWave Speed c = 50.0 m/s\nCourant Number C = 0.90\n\n\n\n\n\n\n\n\nFigure 3.6: Displacement of the robot link’s end-effector over time, showing vibrations induced by a motor jolt.",
    "crumbs": [
      "Partial Differential Equations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Lab Session 2: Solving First-Order Linear PDEs Using Finite Difference Method (FDM)</span>"
    ]
  },
  {
    "objectID": "03-laplace-basics.html",
    "href": "03-laplace-basics.html",
    "title": "4  Lab Session 3: Symbolic operations in Laplace Trandform",
    "section": "",
    "text": "4.1 Experiment 5: The Laplace Transform and Frequency Response\nThe Laplace Transform is a powerful mathematical tool used extensively in circuit analysis, control systems, and signal processing. It transforms a function from the time domain, \\(f(t)\\), into the frequency domain, \\(F(s)\\).\nWhile this is useful for solving differential equations, its true power in engineering comes from analyzing the frequency response. By setting the complex variable \\(s = j\\omega\\) (where \\(j\\) is the imaginary unit and \\(\\omega\\) is angular frequency), we can see how a system or signal behaves at different frequencies. This is analyzed through two key plots: the Magnitude Plot and the Phase Plot.",
    "crumbs": [
      "Laplace Transforms & System Analysis",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lab Session 3: Symbolic operations in Laplace Trandform</span>"
    ]
  },
  {
    "objectID": "03-laplace-basics.html#experiment-5-the-laplace-transform-and-frequency-response",
    "href": "03-laplace-basics.html#experiment-5-the-laplace-transform-and-frequency-response",
    "title": "4  Lab Session 3: Symbolic operations in Laplace Trandform",
    "section": "",
    "text": "4.1.1 Aim\nTo compute the Laplace transform of given functions and, most importantly, to visualize and interpret their frequency response through magnitude and phase plots.\n\n\n4.1.2 Objectives\n\nTo use Python’s SymPy library for symbolic Laplace transforms.\nTo understand how to obtain the frequency response function \\(F(j\\omega)\\) from the Laplace transform \\(F(s)\\).\nTo generate and interpret magnitude and phase plots.\nTo connect these plots to physical concepts like amplification, attenuation, and time delay (phase shift).\n\n\n\n\n4.1.3 Algorithm\n\nDefine Symbols: Use sp.symbols() to declare symbolic variables t (time), s (Laplace variable), and w (frequency, \\(\\omega\\)).\nDefine the Function: Specify the time-domain function \\(f(t)\\) as a symbolic expression.\nCompute Laplace Transform: Use sp.laplace_transform() to find the corresponding \\(F(s)\\).\nDerive Frequency Response: Substitute \\(s = j\\omega\\) into the symbolic expression for \\(F(s)\\) to get the frequency response function \\(F(j\\omega)\\).\nPrepare for Plotting: Convert the symbolic expressions for \\(f(t)\\) and \\(F(j\\omega)\\) into fast numerical functions using sp.lambdify().\nGenerate Data:\n\nCreate a numerical array of time points t_values.\nCreate a logarithmic array of frequency points w_values using np.logspace().\nCalculate the complex values of \\(F(j\\omega)\\) for the frequency range.\n\nCalculate Magnitude and Phase:\n\nMagnitude: np.abs(F_jw_values)\nPhase: np.angle(F_jw_values, deg=True) (in degrees for easier interpretation)\n\nPlot: Create three subplots: the time-domain signal, the magnitude plot (log-log scale), and the phase plot (log-x scale). This set of frequency plots is known as a Bode Plot.\n\n\n\n\n4.1.4 Case Study: An RC Low-Pass Filter’s Impulse Response\nProblem: The voltage response of a simple RC low-pass filter to a sharp input (an impulse) is an exponential decay function, \\(f(t) = e^{-at}\\), where \\(a = 1/RC\\). Let’s analyze this signal for \\(a=1\\).\nPhysical Interpretation: * Magnitude |F(jω)|: Tells us how much the filter will pass or block a sine wave of frequency \\(\\omega\\). * Phase arg(F(jω)): Tells us how much the filter will delay a sine wave of frequency \\(\\omega\\).\n\n\nCode\nimport sympy as sp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- 1. Define symbols ---\nt, s, w = sp.symbols('t s w', real=True, positive=True)\na = sp.Symbol('a', real=True, positive=True)\n\n# --- 2. Define the function ---\nf = sp.exp(-a*t)\n\n# --- 3. Compute Laplace Transform ---\nF_s = sp.laplace_transform(f, t, s, noconds=True)\n\n# --- Set parameter for our specific case ---\nf_case = f.subs(a, 1)\nF_s_case = F_s.subs(a, 1)\n\n# --- 4. Derive Frequency Response ---\nF_jw = F_s_case.subs(s, 1j * w)\n\n# --- Print the symbolic results ---\nprint(f\"Function: f(t) = {f_case}\")\nprint(f\"Laplace Transform: F(s) = {F_s_case}\")\nprint(f\"Frequency Response: F(jω) = {F_jw}\")\n\n# --- 5. Lambdify for numerical evaluation ---\nf_func = sp.lambdify(t, f_case, 'numpy')\nF_jw_func = sp.lambdify(w, F_jw, 'numpy')\n\n# --- 6. & 7. Generate Data and Calculate Mag/Phase ---\nt_values = np.linspace(0, 5, 400)\nf_values = f_func(t_values)\n\nw_values = np.logspace(-1, 2, 400) # From 0.1 to 100 rad/s\nF_jw_values = F_jw_func(w_values)\n\nmagnitude = np.abs(F_jw_values)\nphase = np.angle(F_jw_values, deg=True)\n\n# --- 8. Plotting ---\nplt.figure(figsize=(10, 8))\n\n# Plot f(t)\nplt.subplot(3, 1, 1)\nplt.plot(t_values, f_values, color='blue')\nplt.title('Time Domain: $f(t) = e^{-t}$ (Impulse Response of RC Filter)')\nplt.xlabel('Time (t)')\nplt.ylabel('Amplitude')\nplt.grid(True)\n\n# Plot Magnitude |F(jω)|\nplt.subplot(3, 1, 2)\nplt.loglog(w_values, magnitude, color='red')\nplt.title('Frequency Response: Magnitude Plot')\nplt.xlabel('Frequency (ω) [rad/s]')\nplt.ylabel('|F(jω)| (Gain)')\nplt.grid(True, which=\"both\", ls=\"-\")\n\n# Plot Phase arg(F(jω))\nplt.subplot(3, 1, 3)\nplt.semilogx(w_values, phase, color='purple')\nplt.title('Frequency Response: Phase Plot')\nplt.xlabel('Frequency (ω) [rad/s]')\nplt.ylabel('Phase (degrees)')\nplt.grid(True, which=\"both\", ls=\"-\")\n\nplt.tight_layout()\nplt.show()\n\n\nFunction: f(t) = exp(-t)\nLaplace Transform: F(s) = 1/(s + 1)\nFrequency Response: F(jω) = 1/(1.0*I*w + 1)\n\n\n\n\n\n\n\n\nFigure 4.1: Time-domain plot of an exponential decay and its corresponding Bode Plot (Magnitude and Phase).\n\n\n\n\n\n\n\n4.1.5 Results and Discussion\n\nTime Domain: The function \\(e^{-t}\\) shows a sharp start at 1, followed by a slow decay.\nMagnitude Plot: This plot clearly shows the behavior of a low-pass filter. At low frequencies (e.g., \\(\\omega&lt;1\\)), the magnitude (gain) is close to 1, meaning these signals are passed through without attenuation. As frequency increases, the magnitude rolls off, indicating that high-frequency signals are blocked. The “corner frequency” where the roll-off begins is at \\(\\omega=1/a=1\\) rad/s.\nPhase Plot: At very low frequencies, the phase shift is near 0 degrees. As the frequency approaches the corner frequency, the phase lag increases, reaching -45 degrees at \\(\\omega=1\\) rad/s. At very high frequencies, the phase shift approaches -90 degrees, meaning a high-frequency sine wave passing through this filter will be delayed by a quarter of its cycle. This delay is a fundamental property of physical systems like filters.\n\n\n\n4.1.6 Application Challenge 1: A Damped Oscillator\nYour Task: Analyze a signal representing a damped sine wave, which is characteristic of many mechanical and electrical systems that oscillate but lose energy over time (e.g., a mass on a spring with friction, or an RLC circuit). The function is given by: \\(f(t)=e^{-at}\\sin(\\omega t)\\). Use the following parameters: \\(a = 0.5\\) (Damping factor), \\(\\omega_0 =5\\) rad/s (Natural oscillation frequency). Follow the full algorithm to produce the time-domain plot and the full Bode plot (magnitude and phase).\n\nSolution to the Application Challenge\n\n\n\nCode\n# --- Define symbols and parameters ---\nt, s, w = sp.symbols('t s w', real=True, positive=True)\na = sp.Symbol('a', real=True, positive=True)\nw0 = sp.Symbol('w0', real=True, positive=True)\n\n# --- Define the function ---\nf_damped = sp.exp(-a*t) * sp.sin(w0*t)\n\n# --- Compute its Laplace Transform using the frequency shift theorem ---\n# The transform of e^(-at)f(t) is F(s+a)\nF_s_damped = sp.laplace_transform(sp.sin(w0*t), t, s)[0].subs(s, s + a)\n\n# --- Set parameters for our specific case ---\nparams = {a: 0.5, w0: 5}\nf_case_damped = f_damped.subs(params)\nF_s_case_damped = F_s_damped.subs(params)\n\n# --- Derive Frequency Response ---\nF_jw_damped = F_s_case_damped.subs(s, 1j * w)\n\n# --- Print the symbolic results ---\nprint(f\"Function: f(t) = {f_case_damped}\")\nprint(f\"Laplace Transform: F(s) = {sp.simplify(F_s_case_damped)}\")\nprint(f\"Frequency Response: F(jω) = {F_jw_damped}\")\n\n# --- Lambdify for numerical evaluation ---\nf_damped_func = sp.lambdify(t, f_case_damped, 'numpy')\nF_jw_damped_func = sp.lambdify(w, F_jw_damped, 'numpy')\n\n# --- Generate Data ---\nt_values = np.linspace(0, 8, 500)\nf_values = f_damped_func(t_values)\n\nw_values = np.logspace(-1, 2, 500)\nF_jw_values = F_jw_damped_func(w_values)\nmagnitude = np.abs(F_jw_values)\nphase = np.angle(F_jw_values, deg=True)\n\n# --- Plotting (with raw strings for all labels) ---\nplt.figure(figsize=(10, 8))\n\nplt.subplot(3, 1, 1)\nplt.plot(t_values, f_values, color='blue')\nplt.title(r'Time Domain: Damped Sine Wave $f(t) = e^{-0.5t} \\sin(5t)$')\nplt.xlabel(r'Time (t)')\nplt.ylabel(r'Amplitude')\nplt.grid(True)\n\nplt.subplot(3, 1, 2)\nplt.loglog(w_values, magnitude, color='red')\nplt.title(r'Frequency Response: Magnitude Plot')\nplt.axvline(x=5, color='gray', linestyle='--', label=r'Natural Freq. ($\\omega_{0}$=5)')\nplt.xlabel(r'Frequency ($\\omega$) [rad/s]')\nplt.ylabel(r'|F(j$\\omega$)| (Gain)')\nplt.legend()\nplt.grid(True, which=\"both\", ls=\"-\")\n\nplt.subplot(3, 1, 3)\nplt.semilogx(w_values, phase, color='purple')\nplt.title(r'Frequency Response: Phase Plot')\nplt.axvline(x=5, color='gray', linestyle='--', label=r'Natural Freq. ($\\omega_{0}$=5)')\nplt.xlabel(r'Frequency ($\\omega$) [rad/s]')\nplt.ylabel(r'Phase (degrees)')\nplt.legend()\nplt.grid(True, which=\"both\", ls=\"-\")\n\nplt.tight_layout()\nplt.show()\n\n\nFunction: f(t) = exp(-0.5*t)*sin(5*t)\nLaplace Transform: F(s) = 5/((s + 0.5)**2 + 25)\nFrequency Response: F(jω) = 5/((1.0*I*w + 0.5)**2 + 25)\n\n\n\n\n\n\n\n\nFigure 4.2: Analysis of a damped sine wave, showing a resonant peak in its frequency response.\n\n\n\n\n\n\nDiscussion of Challenge Solution\n\n\nTime Domain: The signal is a sine wave whose amplitude decays exponentially over time, which is exactly what we expect from the function.\nMagnitude Plot: This plot shows a clear resonant peak. The gain is highest for input frequencies very close to the system’s natural oscillation frequency, \\(\\omega_0=5\\) rad/s. This means if you “excite” this system with a frequency of 5 rad/s, it will respond with the largest amplitude. This phenomenon is critical in understanding both mechanical resonance (e.g., why soldiers break step on bridges) and electrical resonance (e.g., tuning a radio).\nPhase Plot: The phase experiences a very rapid shift of 180 degrees around the resonant frequency. It starts at 0 degrees (for very low frequencies), drops sharply to -180 degrees through the resonance point, indicating a complete inversion of the signal’s phase. This sharp phase change is a key indicator of resonance in a system.\n\n\nResult\n\nBy focusing on magnitude and phase, this experiment provides us with a much deeper and more practical understanding of the Laplace transform’s role in engineering.\n\n\n\n4.1.7 Application Challenge 2: Combined Decay and Ramp Signal\nYour Task: Consider a signal that represents the voltage in a circuit with both a discharging capacitor component and a linearly increasing input voltage. The combined signal is given by: \\[\nf(t) = A e^{-\\alpha t} + B t\n\\]\nCompute and visualize the Laplace transform and frequency response for this function using the following parameters:\n\nA = 5 (Initial amplitude of the exponential decay)\n\\(\\alpha = 2\\) (Decay rate)\nB = 3 (Slope of the ramp function)\n\nFollow the full algorithm to produce the time-domain plot and the full Bode plot (magnitude and phase).\n\n\n\n4.1.8 Solution to the Application Challenge 2\nHere is the complete Python code to solve the application challenge. We’ll analyze how the combination of a decaying signal and a constantly growing ramp signal appears in the frequency domain.\n\n\nCode\n# --- Define symbols and parameters ---\nimport sympy as sp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nt, s, w = sp.symbols('t s w', real=True, positive=True)\nA, alpha, B = sp.symbols('A alpha B', real=True, positive=True)\n\n# --- Define the function ---\nf_combined = A * sp.exp(-alpha * t) + B * t\n\n# --- Compute its Laplace Transform ---\n# SymPy can handle the sum directly due to the linearity of the transform\nF_s_combined = sp.laplace_transform(f_combined, t, s)[0]\n\n# --- Set parameters for our specific case ---\nparams = {A: 5, alpha: 2, B: 3}\nf_case_combined = f_combined.subs(params)\nF_s_case_combined = F_s_combined.subs(params)\n\n# --- Derive Frequency Response ---\nF_jw_combined = F_s_case_combined.subs(s, 1j * w)\n\n# --- Print the symbolic results ---\nprint(f\"Function: f(t) = {f_case_combined}\")\n# We can use simplify to combine the terms into a single fraction\nprint(f\"Laplace Transform: F(s) = {sp.simplify(F_s_case_combined)}\")\nprint(f\"Frequency Response: F(jω) = {F_jw_combined}\")\n\n# --- Lambdify for numerical evaluation ---\nf_combined_func = sp.lambdify(t, f_case_combined, 'numpy')\nF_jw_combined_func = sp.lambdify(w, F_jw_combined, 'numpy')\n\n# --- Generate Data ---\nt_values = np.linspace(0, 3, 400)\nf_values = f_combined_func(t_values)\n\n# Frequency range for plotting (logarithmic scale)\nw_values = np.logspace(-1, 2, 400) # From 0.1 to 100 rad/s\nF_jw_values = F_jw_combined_func(w_values)\n\n# Calculate Magnitude and Phase\nmagnitude = np.abs(F_jw_values)\nphase = np.angle(F_jw_values, deg=True)\n\n# --- Plotting ---\nplt.figure(figsize=(10, 8))\n\n# Plot f(t)\nplt.subplot(3, 1, 1)\nplt.plot(t_values, f_values, color='blue')\nplt.title(r'Time Domain: $f(t) = 5e^{-2t} + 3t$')\nplt.xlabel(r'Time (t)')\nplt.ylabel(r'Amplitude')\nplt.grid(True)\n\n# Plot Magnitude |F(jω)|\nplt.subplot(3, 1, 2)\nplt.loglog(w_values, magnitude, color='red')\nplt.title(r'Frequency Response: Magnitude Plot')\nplt.xlabel(r'Frequency ($\\omega$) [rad/s]')\nplt.ylabel(r'|F(j$\\omega$)| (Gain)')\nplt.grid(True, which=\"both\", ls=\"-\")\n\n# Plot Phase arg(F(jω))\nplt.subplot(3, 1, 3)\nplt.semilogx(w_values, phase, color='purple')\nplt.title(r'Frequency Response: Phase Plot')\nplt.xlabel(r'Frequency ($\\omega$) [rad/s]')\nplt.ylabel(r'Phase (degrees)')\nplt.grid(True, which=\"both\", ls=\"-\")\n\nplt.tight_layout()\nplt.show()\n\n\nFunction: f(t) = 3*t + 5*exp(-2*t)\nLaplace Transform: F(s) = 5/(s + 2) + 3/s**2\nFrequency Response: F(jω) = 5/(1.0*I*w + 2) - 3.0/w**2\n\n\n\n\n\n\n\n\nFigure 4.3: Analysis of a combined exponential decay and ramp signal.\n\n\n\n\n\n\n4.1.8.1 Results and Discussion of the Challenge\nThe symbolic computation confirms that the Laplace transform of \\(f(t)=5e^{-2t}+3t\\) is, \\(F(s)=\\frac{5}{s^2+2}+\\frac{2}{s^2}\\). The frequency analysis reveals how these two components interact.\n\nTime-Domain Plot: The plot shows the function starting at an amplitude of 5 (from the \\(Ae^{-at}\\) term). For a short time, the function’s value decreases as the exponential decay is stronger than the ramp’s growth. However, as t increases, the decay term vanishes and the ramp term (\\(3t\\)) dominates, causing the signal to increase linearly.\nMagnitude Plot: The magnitude plot is dominated by the ramp function at low frequencies. The \\(\\frac{1}{s^2}\\) term in the transform results in a very high magnitude as \\(\\omega \\to 0\\). This is because a ramp is a signal with infinite energy concentrated at the lowest frequencies (it never stops growing). The plot shows a steep roll-off, characteristic of this term. The influence of the exponential term \\(\\frac{5}{s+2}\\) is seen as a “shoulder” in the plot around \\(\\omega=2\\) rad/s, but it’s a minor feature compared to the ramp’s overwhelming low-frequency content.\nPhase Plot: The phase plot is particularly interesting. At very low frequencies, the phase approaches -180 degrees. This is a direct consequence of the \\(\\frac{1}{s^2}\\) term from the ramp. In the frequency domain, \\(s^2\\to (j\\omega)^2\\to -\\omega^2\\). A negative real number has a phase of -180 degrees (or +180). As frequency increases, the phase begins to rise, influenced by the other term in the transform, whose phase is between 0 and -90 degrees. This shows the complex interplay between the phase characteristics of the two combined signals.\n\nThis analysis demonstrates how the frequency response can deconstruct a complex time-domain signal, revealing the distinct spectral “fingerprints” of its constituent parts.",
    "crumbs": [
      "Laplace Transforms & System Analysis",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lab Session 3: Symbolic operations in Laplace Trandform</span>"
    ]
  },
  {
    "objectID": "03-laplace-basics.html#experiment-6-the-inverse-laplace-transform",
    "href": "03-laplace-basics.html#experiment-6-the-inverse-laplace-transform",
    "title": "4  Lab Session 3: Symbolic operations in Laplace Trandform",
    "section": "4.2 Experiment 6: The Inverse Laplace Transform",
    "text": "4.2 Experiment 6: The Inverse Laplace Transform\nAfter analyzing a system or signal in the frequency domain, we often need to return to the time domain to understand the actual physical behavior—how voltage changes, how a robot arm moves, etc. The Inverse Laplace Transform, denoted \\(\\mathcal{L}^{-1}\\{F(s)\\}\\), accomplishes this, converting a function \\(F(s)\\) back into its time-domain equivalent, \\(f(t)\\).\n\n4.2.1 Aim\nTo compute the Inverse Laplace transform of given s-domain functions and to visualize the connection between the frequency-domain characteristics and the resulting time-domain signal.\n\n\n4.2.2 Objectives\n\nTo use SymPy to calculate the inverse Laplace transform of a given function \\(F(s)\\).\nTo analyze the frequency response (magnitude and phase) of the given \\(F(s)\\).\nTo plot the resulting time-domain function \\(f(t)\\).\nTo visually connect features in the frequency domain (like resonant peaks) to behaviors in the time domain (like oscillations).\n\n\n\n\n4.2.3 Algorithm\n\nImport Libraries: Import sympy, numpy, and matplotlib.pyplot.\nDefine Symbols: Declare symbolic variables s, t, and w.\nDefine Laplace-Domain Function: Specify the s-domain function \\(F(s)\\) as a symbolic expression.\nAnalyze Frequency Response of F(s):\n\nSubstitute \\(s = j\\omega\\) to get the frequency response function \\(F(j\\omega)\\).\nLambdify \\(F(j\\omega)\\) to prepare for numerical plotting.\nGenerate a frequency array w_values and calculate the magnitude and phase of \\(F(j\\omega)\\).\n\nCompute the Inverse Laplace Transform:\n\nUse sp.inverse_laplace_transform(F, s, t)[0] to find the time-domain function \\(f(t)\\).\nLambdify the resulting symbolic expression \\(f(t)\\).\n\nPlot and Visualize: Create a set of plots to show the full picture:\n\nThe Magnitude plot of \\(F(j\\omega)\\).\nThe Phase plot of \\(F(j\\omega)\\).\nThe resulting time-domain plot of \\(f(t)\\).\n\n\n\n\n\n4.2.4 Case Study: An Ideal Resonator\nProblem: You are given the s-domain function \\(F(s) = \\frac{1}{s^2 + 1}\\). This is the transfer function of an ideal, undamped second-order system (like a frictionless mass-spring or a lossless LC circuit). Analyze its frequency response and find its impulse response in the time domain by computing the inverse Laplace transform.\nTheoretical Result: This is the classic transform pair for \\(\\sin(t)\\).\n\n\nCode\nimport sympy as sp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- 1. & 2. Define symbols ---\ns, t, w = sp.symbols('s t w', real=True, positive=True)\n\n# --- 3. Define Laplace-domain function ---\nF_s = 1 / (s**2 + 1)\n\n# --- 4. Analyze Frequency Response of F(s) ---\nF_jw = F_s.subs(s, 1j * w)\nF_jw_func = sp.lambdify(w, F_jw, 'numpy')\n\nw_values = np.logspace(-1, 2, 500)\nF_jw_values = F_jw_func(w_values)\nmagnitude = np.abs(F_jw_values)\nphase = np.angle(F_jw_values, deg=True)\n\n# --- 5. Compute Inverse Laplace Transform ---\nf_t = sp.inverse_laplace_transform(F_s, s, t, noconds=True)\nf_t_func = sp.lambdify(t, f_t, 'numpy')\n\nprint(f\"The given F(s) is: {F_s}\")\nprint(f\"The computed Inverse Laplace Transform f(t) is: {f_t}\")\n\n# --- 6. Plotting ---\nt_values = np.linspace(0, 10, 500)\n\nplt.figure(figsize=(10, 8))\n\n# Plot Magnitude\nplt.subplot(3, 1, 1)\nplt.loglog(w_values, magnitude, color='red')\nplt.title(r'Frequency Response of $F(s)$: Magnitude')\nplt.ylabel(r'|F(j$\\omega$)| (Gain)')\nplt.axvline(x=1, color='gray', linestyle='--', label=r'Resonant Freq. ($\\omega$=1)')\nplt.grid(True, which=\"both\", ls=\"-\")\nplt.legend()\n\n# Plot Phase\nplt.subplot(3, 1, 2)\nplt.semilogx(w_values, phase, color='purple')\nplt.title(r'Frequency Response of $F(s)$: Phase')\nplt.ylabel(r'Phase (degrees)')\nplt.axvline(x=1, color='gray', linestyle='--', label=r'Resonant Freq. ($\\omega$=1)')\nplt.grid(True, which=\"both\", ls=\"-\")\nplt.legend()\n\n# Plot Time-domain response f(t)\nplt.subplot(3, 1, 3)\nplt.plot(t_values, f_t_func(t_values), color='blue')\nplt.title(r'Resulting Time-Domain Function: $f(t) = \\mathcal{L}^{-1}\\{F(s)\\}$')\nplt.xlabel(r'Time (t)')\nplt.ylabel(r'$f(t)$')\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n\n\nThe given F(s) is: 1/(s**2 + 1)\nThe computed Inverse Laplace Transform f(t) is: sin(t)\n\n\n\n\n\n\n\n\nFigure 4.4: Bode Plot of F(s) = 1/(s^2+1) and its corresponding time-domain response, f(t)=sin(t).\n\n\n\n\n\n\n4.2.4.1 Results and Discussion\nThis example provides a perfect illustration of the connection between the frequency and time domains.\n\nFrequency Domain Analysis: The magnitude plot shows an infinitely sharp resonant peak at \\(\\omega=1\\) rad/s. This tells us the system is extremely sensitive to inputs at this specific frequency and will have a massive response. The phase plot shows an instantaneous 180-degree flip at \\(\\omega=1\\), another hallmark of ideal resonance.\nTime Domain Result: The inverse Laplace transform correctly yields \\(f(t)=sin(t)\\). The plot of this function is an undamped sine wave that oscillates forever. This is the time-domain manifestation of the infinite resonant peak seen in the frequency domain. An undamped system, when “hit” by an impulse, will oscillate at its natural frequency indefinitely.",
    "crumbs": [
      "Laplace Transforms & System Analysis",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lab Session 3: Symbolic operations in Laplace Trandform</span>"
    ]
  },
  {
    "objectID": "03-laplace-basics.html#application-challenge-step-response-of-an-rlc-circuit",
    "href": "03-laplace-basics.html#application-challenge-step-response-of-an-rlc-circuit",
    "title": "4  Lab Session 3: Symbolic operations in Laplace Trandform",
    "section": "4.3 Application Challenge: Step Response of an RLC Circuit",
    "text": "4.3 Application Challenge: Step Response of an RLC Circuit\nProblem: Consider a series RLC circuit which is initially at rest (zero initial conditions). A step voltage of 5 volts is applied at \\(t=0\\). Determine the step response of the circuit, i.e., the current \\(i(t)\\) as a function of time, using the inverse Laplace transform method. Use the following component values:\n\nResistance (R): 10 Ω\nInductance (L): 0.1 H\nCapacitance (C): 0.001 F (1 mF)\n\n\nCircuit Analysis\n\nFor a series RLC circuit, Kirchhoff’s Voltage Law (KVL) gives:\n\\[\nL \\frac{di(t)}{dt} + R i(t) + \\frac{1}{C} \\int_0^t i(\\tau) \\, d\\tau = v_s(t)\n\\]\nTaking the Laplace transform of the entire equation (with zero initial conditions):\n\\[\nsLI(s) + RI(s) + \\frac{1}{sC}I(s) = V(s)\n\\]\nThe input is a step voltage of 5V, so \\(v_s(t) = 5u(t)\\), and its transform is \\(V(s) = \\frac{5}{s}\\). Substituting for \\(V(s)\\) and solving for the current \\(I(s)\\):\n\\[\nI(s) \\left( sL + R + \\frac{1}{sC} \\right) = \\frac{5}{s} \\implies I(s) = \\frac{\\frac{5}{s}}{sL + R + \\frac{1}{sC}}\n\\]\nSimplifying this expression gives us the function we need to find the inverse transform of:\n\\[\nI(s) = \\frac{5/L}{s^2 + \\frac{R}{L}s + \\frac{1}{LC}}\n\\]\n\n\nCode\nimport sympy as sp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- Define symbols and parameters ---\ns, t = sp.symbols('s t', real=True, positive=True)\nR_val, L_val, C_val, V_val = 10, 0.1, 0.001, 5\n\n# --- Define the s-domain function I(s) ---\n# Derived from the circuit analysis above\nI_s = (V_val / L_val) / (s**2 + (R_val / L_val) * s + 1 / (L_val * C_val))\nprint(f\"The s-domain expression for the current is I(s) =\")\nsp.pprint(I_s)\n\n# --- Compute the Inverse Laplace Transform to find i(t) ---\n# &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; FIX IS HERE: Add noconds=True &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\ni_t = sp.inverse_laplace_transform(I_s, s, t, noconds=True)\n# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nprint(\"\\nThe time-domain expression for the current is i(t) =\")\nsp.pprint(i_t)\n\n# --- Lambdify for plotting ---\ni_t_func = sp.lambdify(t, i_t, 'numpy')\n\n# --- Generate time values and plot ---\nt_values = np.linspace(0, 0.1, 500) # The action happens quickly\ni_values = i_t_func(t_values)\n\nplt.figure(figsize=(10, 5))\nplt.plot(t_values, i_values, color='blue')\nplt.title(r'RLC Circuit Step Response: Current $i(t)$')\nplt.xlabel(r'Time (t) [seconds]')\nplt.ylabel(r'Current (i) [Amps]')\nplt.grid(True)\nplt.show()\n\n\nThe s-domain expression for the current is I(s) =\n         50.0         \n──────────────────────\n 2                    \ns  + 100.0⋅s + 10000.0\n\nThe time-domain expression for the current is i(t) =\n                   -50.0⋅t                        \n0.577350269189626⋅ℯ       ⋅sin(86.6025403784439⋅t)\n\n\n\n\n\n\n\n\nFigure 4.5: The current i(t) in an RLC circuit after a 5V step input is applied.\n\n\n\n\n\n\n4.3.0.1 Discussion of RLC Circuit Result\nThe inverse Laplace transform provides the exact analytical solution for the current \\(i(t)\\) in the circuit.\n\nUnderdamped Response: The plot shows a classic underdamped response. When the voltage is applied, the current surges to a peak, overshoots the final steady-state value, and then oscillates with decreasing amplitude until it settles.\nSteady-State Behavior: As \\(t\\to \\infty\\), the current \\(i(t)\\to 0\\). This is physically correct. In a DC circuit, after the initial transient period, the inductor acts like a short circuit (a wire) and the capacitor acts as an open circuit. Since the capacitor blocks the DC current in the steady state, the final current must be zero.\nConnection to System Poles: The oscillatory behavior is due to the complex conjugate poles of the denominator of \\(I(s)\\). If the poles were real and distinct, the response would be overdamped (no oscillation). If the poles were real and repeated, it would be critically damped. This problem beautifully demonstrates how the mathematical properties of \\(F(s)\\) directly dictate the physical nature of \\(f(t)\\).",
    "crumbs": [
      "Laplace Transforms & System Analysis",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lab Session 3: Symbolic operations in Laplace Trandform</span>"
    ]
  }
]